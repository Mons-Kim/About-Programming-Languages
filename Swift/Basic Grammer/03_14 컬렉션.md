# 컬렉션

- 데이터의 모음을 쉽게 처리하기 위해 사용하는 특별한 자료형(Array, Dictionary, Set, ...)
  - Array - 데이터를 순서대로 저장하는 컬렉션
  - Dictionary - Key/Value 페어로 저장하는 컬렉션
  - Set - 집합 연산을 편리하게 수행할 수 있는 컬렉션

- Foundation 프레임워크에서 제공하는 컬렉션 클래스와  Swift Standard Library에서 제공하는 컬렉션 구조체를 모두 사용 가능
  - Foundation 컬렉션 - 저장요소가 객체로 제한(값 형식 저장 불가. 객체로 박싱 후 저장 가능). 저장하는 자료형의 제한이 없어 서로 다른 자료형의 객체를 하나의 컬렉션에서 저장 가능
  - Swift 컬렉션 - 참조형식, 값 형식 모두 저장 가능(값 형식 박싱없이 저장 가능). 저장할 요소의 자료형을 선언 시점에 명시적으로 지정해야 함.(서로 다른 자료형의 데이터 저장 불가)


### 1. 컬렉션의 가변성

|                   |    불변형    |       가변형        |
| :---------------: | :----------: | :-----------------: |
| Foundation 컬렉션 |   NSArray    |   NSMutableArray    |
|                   | NSDictionary | NSMutableDIctionary |
|                   |    NSSet     |    NSMutableSet     |
|   Swift 컬렉션    | let으로 선언 |     var로 선언      |

- 가변형과 불변형의 구분은 스레드 안정성에서 큰 이점을 가짐

- 컬렉션 생성 후, 수정할 필요가 없는 경우 항상 불변 컬렉션을 사용하는 것을 추천

  

### 2. Swift 컬렉션 최적화

- Swift 컬렉션은 모두 구조체로 구현된 값 형식임. 값 사용시 복사 작업 수행필요.
- 컬렉션 자료형은 데이터의 크기가 크기 때문에 무조건 복사 작업을 수행하는 것은 성능을 저하시킴
- 단점 극복을 위해 문자열과 마찬가지로 복사가 필요한 경우에만 실제 복사를 수행하도록 최적화함
  - 한 배열을 다른 변수에 할당시,즉시 복사가 발생하는 것이 아니라 다른 변수에서 값의 수정이 발생하는 경우에 복사 수행을 함




### 3. 배열

- 요소를 순서대로 정렬하는 컬렉션

  ```swift
  [요소1, 요소2, 요소3, ..., 요소N]
  [] // 빈 배열
  ```

  ```swift
  // 배열의 자료형 표현 방식
  Array<요소의 자료형> 
  [요소의 자료형] // 단축 문법
  ```

  

- Swift에서 빈 배열을 생성할 때는 형식 추론에 필요한 정보가 없기 때문에, 반드시 배열에 저장할 자료형을 지정해야 함

  ```swift
  // Swift Array
  let stringArray = ["Apple", "Orange", "Banana"]
  
  // Foundation Array
  let stringNSArray: NSArray = ["Apple", "Orange", "Banana"]
  ```

  ```swift
  // 생성자를 이용한 선언
  let stringArray = Array(["Apple", "Orange", "Banana"])
  let stringNSArray = NSArray(objects: "Apple", "Orange", "Banana")
  ```

  ```swift
  // 빈 배열 선언
  // Foundation Array
  let emptyArray1: NSMutableArray = []
  let emptyArray2 = NSMutableArray()
  
  // Swift Array
  var emptyStringArray1: Array<String> = []
  var emptyStringArray2 = Array<String>()
  var emptyStringArray3: [String] = []
  var emptyStringArray4 = [String]()
  
  var emptyArray = [] // Error
  ```

  

#### 3.1 배열에 포함된 요소의 수

- 요소의 수는 count속성으로 확인 가능

- Array 배열의 경우 isEmpty 속성 사용 가능

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  let countOfFruits = fruits.count
  
  if !fruits.isEmpty {
      print("\(countOfFruits) element(s)")
  } else {
      print("empty array")
  }
  // 3 element(s)
  ```



#### 3.2 요소에 접근

- 정수 인덱스로 요소에 접근. 인덱스는 배열이 제공하는 메소드 또는 서브스크립트 문법으로 전달

- NSArray - object(at: ) 메소드를 제공

  ```swift
  let fruits: NSArray = ["Apple", "Orange", "Banana"]
  let first = fruits.object(at: 0)
  let last = fruits.object(at: fruits.count -1)
  
  print(first)
  print(last)
  // Apple
  // Banana
  ```

  ```swift
  let fruits: NSArray = ["Apple", "Orange", "Banana"]
  let first = fruits[0]
  let last = fruits[fruits.count -1]
  ```

- Array - startIndex, endIndex 속성을 제공

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  let index = 100
  if index >= fruits.startIndex && index < fruits.endIndex {
      // ...
  }
  ```

- 배열은 첫번째 요소와 마지막 요소에 접근할 수 있는 특별한 속성을 제공

  - NSArray - firstObject, lastObject
  - Array - first, last
  - 배열이 비어있는 경우 nil을 리턴하므로 값을 사용하기 전에 유효한 값이 리턴되었는지 확인 필요

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  
  if let first = fruits.first {
      // ...
  }
  
  if let last = fruits.last {
      // ...
  }
  ```



#### 3.3 요소 검색

- NSArray

  - contains(_: ) : 파라미터로 전달된 객체가 NSArray  배열에 포함되어 있는지 확인

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
    
  if alphabet.contains("A") {
      print("contains A")
  }
  // contains A
  ```


  - index(of: ) : 특정 요소의 인덱스를 파악하고 싶을 때 사용. 배열에 전달된 요소가 포함되어 있다면 해당 요소의 인덱스가 리턴되고, 포함되어 있지 않다면 NSNotFound가 리턴

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let index = alphabet.index(of: "C")
    
  if index != NSNotFound {
      print("index of C: \(index)")
  }
  // index of C: 2
  ```

  - filteredArrayUsingPredicate(_: ) : 검색 조건을 지정하여 조건과 일치하는 요소를 파악하고 싶을 때 사용. 검색 조건을 지정하는 NSPredicate 객체를 통해 요소를 비교한 후 조건이 일치하는 요소들을 새로운 배열로 리턴. NSMutableArray 역시 유사한 메소드를 제고하는데 가변 배열의 특성상 새로운 배열을 리턴하지 않고 현재 배열에 포함된 요소 중 조건이 일치하는 요소를 제외한 나머지 요소를 삭제함

  ```swift
  let productNams: NSArray = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
  let prefixPredicate = NSPredicate(format: "SELF BEGINSWITH %@", "i")
  let filteredArray = productNames.filtered(using: prefixPredicate)
  
  print(filteredArray)
  // ["iPhone", "iPad", "iPad Pro"]
  
  let mutableProductNames = NSMutableArray(array: productNames)
  let suffixPredicate = NSPredicate(format: "SELF ENDSWITH %@", "o")
  mutableProductNames.filter(using: suffixPredicate)
  
  print(mutableProductNames)
  // ["Mac Pro", "iPad Pro", "Macbook Pro"]
  ```

- Array

  - contains(_:) : 지정된 요소가 포함되어 있는지 확인하는 메소드. 클로저를 통해 검색 조건을 더욱 상세하게 구현 가능

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  if alphabet.contains("C") {
      print("contains C")
  }
  // contains C
  
  if alphabet.contains(where: { $0 == "A"}) {
      print("contains A")
  }
  // contains A
  ```

  - indexOf(_: ) :  파라미터로 전달된 요소의 인덱스를 옵셔널로 리턴. 배열에 존재하지 않으면 nil을 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let index = alphabet.index(of: "C")
    
  if let index = alphabet.index(of: "C") {
      print("index of C: \(index)")
  }
  // index of C: 2
  ```

  - Array는 NSArray와 달리 클로저를 통해 검색 조건을 구현함

  ```swift
  let productNams = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
  let filteredArray = productNames.filter { (element) -> Bool in
      return element.hasPrefix("i")
  }
  print(filteredArray)
  // ["iPhone", "iPad", "iPad Pro"]
  ```



#### 3.4 배열 비교

- 두 배열이 동일한 배열인지 판단하는 두가지 조건. 
  - 요소의 순서
  - isEqual(_: ) 메소드의 결과(NSArray) 또는 == 연산자로 비교한 결과(Array)

- NSArray

  - isEqual(to: ) : 요소에 저정된 순서와 대소문자가 완전히 일치하는 경우에만 같은 배열로 판단.

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let upper = ["A", "B", "C", "D", "E"]
  let shuffled = ["E", "B", "C", "A", "D"]
  let lower = ["a", "b", "c", "d", "e"]
  let mixed = ["A", "b", "C", "d", "e"]
  
  if alphabet.isEqual(to: upper) {
      print("alphabet == upper")
  } else {
      print("alphabet != upper")
  }
  
  if alphabet.isEqual(to: shuffled) {
      print("alphabet == shuffled")
  } else {
      print("alphabet != shuffled")
  }
  
  if alphabet.isEqual(to: lower) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  
  if alphabet.isEqual(to: mixed) {
      print("alphabet == mixed")
  } else {
      print("alphabet != mixed")
  }
  
  // alphabet == upper
  // alphabet != shuffled
  // alphabet != lower
  // alphabet != mixed
  ```

  - isEqual(to: )의 결과로 인해 원하는 결과를 얻을 수 없다면 배열의 모든 요소를 열거하면서 두 배열에 포함된 요소를 비교하는 코드를 직접 구현해야 함.

  ```swift
  // 대소문자에 관계없이 비교
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  var equal = true
  if alphabet.count == lower.count {
      for i in 0..<alphabet.count {
          let lhs = alphabet[i] as! NSString
          let rhs = lower[i]
          
          if lhs.caseInsensitiveCompare(rhs) != .orderSame {
              equal = false
              break
          }
      }
  }
  
  if alphabet.isEqual(to: lower) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet == lower
  ```

- Array

  - elementsEqual(_: ) : 요소의 순서가 동일하고 두 요소를 == 연산자로 비교한 결과가 true인 경우에만 동일 배열로 판단. Swift는 ==연산자로 요소뿐만 아니라 배열 자체를 비교할 수 있음

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  if alphabet == lower {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet != lower
  ```

  - elementsEqual(_: by: ) : 요소의 비교 조건을 상세하게 지정할 때 활용. 비교 조건은 클로저로 전달. 클로저는 두 개의 요소를 비교한 결과를 Bool로 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  if alphabet.elementsEqual(lower, by: { $0.lowercased() == $1.lowercased()}) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet == lower
  ```



#### 3.5 새로운 요소 추가

- NSMutableArray

  - add(_: ) : 새로운 요소를 배열의 마지막에 추가
  - insert(_: at: ) : 원하는 위치에 새로운 요소를 추가

  ```swift
  let alphabet = NSMutableArray()
  alphabet.add("B")
  print(alphabet)
  // ["B"]
  
  alphabet.insert("A", at:0)
  print(alphabet)
  // ["A", "B"]
  ```

- Array (var로 선언된)

  - append(_: ) : NSMutableArray의 add()와 동일
  - insert(_: at: ) : NSMutableArray의 insert()와 동일

  ```swift
  var alphabet = [String]()
  alphabet.append("B")
  print(alphabet)
  // ["B"]
  
  alphabet.insert("A", at:0)
  print(alphabet)
  // ["A", "B"]
  ```



#### 3.6 요소 교체

- 특정 요소 교체

  - NSMutableArray - replaceObject(at: with: ) 메소드 또는 서브 스크립트 문법을 이용
  - Array - 서브 스트립트 문법만 사용 가능

  ```swift
  let alphabet = NSMutableArray(array: ["A", "B", "C"])
  alphabet.replaceObject(at: 0, with: "Z")
  print(alphabet)
  // ["Z", "B", "C"]
  
  alphabet[0] = "Y"
  print(alphabet)
  // ["Y", "B", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet[0] = "Z"
  print(alphabet)
  // ["Z", "B", "C"]
  ```

- 특정 범위의 요소들 교체

  - NSMutableArray - replaceObjects(range: with: ) 메소드 제공
  - Array - replaceRange(_: with: ) 메소드를 제공. 범위는 범위 연산자의 활용이 가능

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C"])
  let range = NSRange(location:0, length:2)
  alphabet.replaceObjects(in: range, withObjectsFrom: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet.replaceSubrange(0..<2, with: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

- 컴파일 시점에 정확한 범위를 파악할 수 없는 경우에는 startIndex, endIndex속성을 활용하여 범위를 구하는 것이 안전

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet.replaceSubrange(alphabet.startIndex..<alphabet.endIndex.advanced(by: -1), with: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet[alphabet.startIndex..<alphabet.endIndex.advanced(by: -1)] = ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

- 모든 요소 교체 / 빈 배열로 초기화

  - NSMutableArray - setArray(_: ) 메소드 제공. 빈 배열로 초기화시 파라미터에 빈 배열 전달
  - Array - 무조건 새로운 배열을 할당

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C"])
  alphabet.setArray(["K", "R"])
  print(alphabet)
  // ["K", "R"]
  
  alphabet.setArray([])
  print(alphabet)
  // [] 빈 배열
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet = ["K", "R"])
  print(alphabet)
  // ["K", "R"]
  
  alphabet = []
  print(alphabet)
  // [] 빈 배열
  ```



#### 3.7 요소 삭제



#### 3.8 정렬



#### 3.9 범위 추출



#### 3.10 배열 변환



#### 3.11 Array 배열의 메모리 공간과 최적화











### 4. Decomposition

- 튜플의 분해 문법(Decomposition Syntax)를 사용하면 튜플에 저장된 멤버를 추출하여 개별 상수나 변수에 저장 가능

```swift
let 또는 var (이름1, 이름2, ...) = 튜플
```

```swift
let member = (1, "James", "Seoul", "010-0000-0000")

let (memberId, name, address, tel) = member

print(memberId)
print(name)
print(address)
print(tel)
// 1
// James
// Seoul
// 010-0000-0000
```

- 튜플을 분해하는 과정에서 모든 값을 분해할 필요가 없다면 불필요한 값을 "_"문자로 제외할 수 있음

  ```swift
  let (_, name, address, tel) = member
  ```

- 튜플을 분해할 때는 반드시 튜플에 저장된 값의 수가 일치해야 함

  ```swift
  let (name, address, tel) = member // Error
  ```

- 분해 문법으로 선언된 상수는 동일한 범위 내에서 유효한 상수임. 이후 동일한 이름을 가진 상수를 선언하는 것은 오류

  ```swift
  let member = (1, "James", "Seoul", "010-0000-0000")
  let (memberId, name, address, tel) = member
  // ...
  let memberId = 123 // Error
  ```

  

### 5. Named Tuples

- 튜플에 저장된 값을 인덱스를 통해 읽는 것은 가독성 측면에서 불리

- 기명 튜플(Named Tuple) - 튜플을 생성할 때 해당 값에 대한 이름 지정. 가독성 좋음

  ```swift
  (이름1: 값1, 이름2: 값2, ...)
  ```

  ```swift
  let member = (id: 1, name: "James", address: "Seoul", phone: "010-0000-0000")
  
  let memberId = member.id
  let name = member.name
  let address = member.address
  let tel = member.phone
  ```

  



