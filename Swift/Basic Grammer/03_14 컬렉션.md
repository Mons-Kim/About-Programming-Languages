# 컬렉션

- 데이터의 모음을 쉽게 처리하기 위해 사용하는 특별한 자료형(Array, Dictionary, Set, ...)
  - Array - 데이터를 순서대로 저장하는 컬렉션
  - Dictionary - Key/Value 페어로 저장하는 컬렉션
  - Set - 집합 연산을 편리하게 수행할 수 있는 컬렉션

- Foundation 프레임워크에서 제공하는 컬렉션 클래스와  Swift Standard Library에서 제공하는 컬렉션 구조체를 모두 사용 가능
  - Foundation 컬렉션 - 저장요소가 객체로 제한(값 형식 저장 불가. 객체로 박싱 후 저장 가능). 저장하는 자료형의 제한이 없어 서로 다른 자료형의 객체를 하나의 컬렉션에서 저장 가능
  - Swift 컬렉션 - 참조형식, 값 형식 모두 저장 가능(값 형식 박싱없이 저장 가능). 저장할 요소의 자료형을 선언 시점에 명시적으로 지정해야 함.(서로 다른 자료형의 데이터 저장 불가)




### 1. 컬렉션의 가변성

|                   |    불변형    |       가변형        |
| :---------------: | :----------: | :-----------------: |
| Foundation 컬렉션 |   NSArray    |   NSMutableArray    |
|                   | NSDictionary | NSMutableDIctionary |
|                   |    NSSet     |    NSMutableSet     |
|   Swift 컬렉션    | let으로 선언 |     var로 선언      |

- 가변형과 불변형의 구분은 스레드 안정성에서 큰 이점을 가짐

- 컬렉션 생성 후, 수정할 필요가 없는 경우 항상 불변 컬렉션을 사용하는 것을 추천

  

### 2. Swift 컬렉션 최적화

- Swift 컬렉션은 모두 구조체로 구현된 값 형식임. 값 사용시 복사 작업 수행필요.
- 컬렉션 자료형은 데이터의 크기가 크기 때문에 무조건 복사 작업을 수행하는 것은 성능을 저하시킴
- 단점 극복을 위해 문자열과 마찬가지로 복사가 필요한 경우에만 실제 복사를 수행하도록 최적화함
  - 한 배열을 다른 변수에 할당시,즉시 복사가 발생하는 것이 아니라 다른 변수에서 값의 수정이 발생하는 경우에 복사 수행을 함




### 3. 배열

- 요소를 순서대로 정렬하는 컬렉션

  ```swift
  [요소1, 요소2, 요소3, ..., 요소N]
  [] // 빈 배열
  ```

  ```swift
  // 배열의 자료형 표현 방식
  Array<요소의 자료형> 
  [요소의 자료형] // 단축 문법
  ```

  

- Swift에서 빈 배열을 생성할 때는 형식 추론에 필요한 정보가 없기 때문에, 반드시 배열에 저장할 자료형을 지정해야 함

  ```swift
  // Swift Array
  let stringArray = ["Apple", "Orange", "Banana"]
  
  // Foundation Array
  let stringNSArray: NSArray = ["Apple", "Orange", "Banana"]
  ```

  ```swift
  // 생성자를 이용한 선언
  let stringArray = Array(["Apple", "Orange", "Banana"])
  let stringNSArray = NSArray(objects: "Apple", "Orange", "Banana")
  ```

  ```swift
  // 빈 배열 선언
  // Foundation Array
  let emptyArray1: NSMutableArray = []
  let emptyArray2 = NSMutableArray()
  
  // Swift Array
  var emptyStringArray1: Array<String> = []
  var emptyStringArray2 = Array<String>()
  var emptyStringArray3: [String] = []
  var emptyStringArray4 = [String]()
  
  var emptyArray = [] // Error
  ```

  

#### 3.1 배열에 포함된 요소의 수

- 요소의 수는 count속성으로 확인 가능

- Array 배열의 경우 isEmpty 속성 사용 가능

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  let countOfFruits = fruits.count
  
  if !fruits.isEmpty {
      print("\(countOfFruits) element(s)")
  } else {
      print("empty array")
  }
  // 3 element(s)
  ```



#### 3.2 요소에 접근

- 정수 인덱스로 요소에 접근. 인덱스는 배열이 제공하는 메소드 또는 서브스크립트 문법으로 전달

- NSArray - object(at: ) 메소드를 제공

  ```swift
  let fruits: NSArray = ["Apple", "Orange", "Banana"]
  let first = fruits.object(at: 0)
  let last = fruits.object(at: fruits.count -1)
  
  print(first)
  print(last)
  // Apple
  // Banana
  ```

  ```swift
  let fruits: NSArray = ["Apple", "Orange", "Banana"]
  let first = fruits[0]
  let last = fruits[fruits.count -1]
  ```

- Array - startIndex, endIndex 속성을 제공

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  let index = 100
  if index >= fruits.startIndex && index < fruits.endIndex {
      // ...
  }
  ```

- 배열은 첫번째 요소와 마지막 요소에 접근할 수 있는 특별한 속성을 제공

  - NSArray - firstObject, lastObject
  - Array - first, last
  - 배열이 비어있는 경우 nil을 리턴하므로 값을 사용하기 전에 유효한 값이 리턴되었는지 확인 필요

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  
  if let first = fruits.first {
      // ...
  }
  
  if let last = fruits.last {
      // ...
  }
  ```



#### 3.3 요소 검색

- NSArray

  - contains(_: ) : 파라미터로 전달된 객체가 NSArray  배열에 포함되어 있는지 확인

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
    
  if alphabet.contains("A") {
      print("contains A")
  }
  // contains A
  ```


  - index(of: ) : 특정 요소의 인덱스를 파악하고 싶을 때 사용. 배열에 전달된 요소가 포함되어 있다면 해당 요소의 인덱스가 리턴되고, 포함되어 있지 않다면 NSNotFound가 리턴

  ```swift
let alphabet: NSArray = ["A", "B", "C", "D", "E"]
let index = alphabet.index(of: "C")
  
if index != NSNotFound {
    print("index of C: \(index)")
}
// index of C: 2
  ```

  - filteredArrayUsingPredicate(_: ) : 검색 조건을 지정하여 조건과 일치하는 요소를 파악하고 싶을 때 사용. 검색 조건을 지정하는 NSPredicate 객체를 통해 요소를 비교한 후 조건이 일치하는 요소들을 새로운 배열로 리턴. NSMutableArray 역시 유사한 메소드를 제고하는데 가변 배열의 특성상 새로운 배열을 리턴하지 않고 현재 배열에 포함된 요소 중 조건이 일치하는 요소를 제외한 나머지 요소를 삭제함

  ```swift
let productNams: NSArray = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
let prefixPredicate = NSPredicate(format: "SELF BEGINSWITH %@", "i")
let filteredArray = productNames.filtered(using: prefixPredicate)

print(filteredArray)
// ["iPhone", "iPad", "iPad Pro"]

let mutableProductNames = NSMutableArray(array: productNames)
let suffixPredicate = NSPredicate(format: "SELF ENDSWITH %@", "o")
mutableProductNames.filter(using: suffixPredicate)

print(mutableProductNames)
// ["Mac Pro", "iPad Pro", "Macbook Pro"]
  ```

- Array

  - contains(_:) : 지정된 요소가 포함되어 있는지 확인하는 메소드. 클로저를 통해 검색 조건을 더욱 상세하게 구현 가능

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  if alphabet.contains("C") {
      print("contains C")
  }
  // contains C
  
  if alphabet.contains(where: { $0 == "A"}) {
      print("contains A")
  }
  // contains A
  ```

  - indexOf(_: ) :  파라미터로 전달된 요소의 인덱스를 옵셔널로 리턴. 배열에 존재하지 않으면 nil을 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let index = alphabet.index(of: "C")
    
  if let index = alphabet.index(of: "C") {
      print("index of C: \(index)")
  }
  // index of C: 2
  ```

  - Array는 NSArray와 달리 클로저를 통해 검색 조건을 구현함

  ```swift
  let productNams = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
  let filteredArray = productNames.filter { (element) -> Bool in
      return element.hasPrefix("i")
  }
  print(filteredArray)
  // ["iPhone", "iPad", "iPad Pro"]
  ```



#### 3.4 배열 비교

- 두 배열이 동일한 배열인지 판단하는 두가지 조건. 

  - 요소의 순서
  - isEqual(_: ) 메소드의 결과(NSArray) 또는 == 연산자로 비교한 결과(Array)

- NSArray

  - isEqual(to: ) : 요소에 저정된 순서와 대소문자가 완전히 일치하는 경우에만 같은 배열로 판단.

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let upper = ["A", "B", "C", "D", "E"]
  let shuffled = ["E", "B", "C", "A", "D"]
  let lower = ["a", "b", "c", "d", "e"]
  let mixed = ["A", "b", "C", "d", "e"]
  
  if alphabet.isEqual(to: upper) {
      print("alphabet == upper")
  } else {
      print("alphabet != upper")
  }
  
  if alphabet.isEqual(to: shuffled) {
      print("alphabet == shuffled")
  } else {
      print("alphabet != shuffled")
  }
  
  if alphabet.isEqual(to: lower) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  
  if alphabet.isEqual(to: mixed) {
      print("alphabet == mixed")
  } else {
      print("alphabet != mixed")
  }
  
  // alphabet == upper
  // alphabet != shuffled
  // alphabet != lower
  // alphabet != mixed
  ```

  - isEqual(to: )의 결과로 인해 원하는 결과를 얻을 수 없다면 배열의 모든 요소를 열거하면서 두 배열에 포함된 요소를 비교하는 코드를 직접 구현해야 함.

  ```swift
  // 대소문자에 관계없이 비교
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  var equal = true
  if alphabet.count == lower.count {
      for i in 0..<alphabet.count {
          let lhs = alphabet[i] as! NSString
          let rhs = lower[i]
          
          if lhs.caseInsensitiveCompare(rhs) != .orderSame {
              equal = false
              break
          }
      }
  }
  
  if alphabet.isEqual(to: lower) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet == lower
  ```

- Array

  - elementsEqual(_: ) : 요소의 순서가 동일하고 두 요소를 == 연산자로 비교한 결과가 true인 경우에만 동일 배열로 판단. Swift는 ==연산자로 요소뿐만 아니라 배열 자체를 비교할 수 있음

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  if alphabet == lower {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet != lower
  ```

  - elementsEqual(_: by: ) : 요소의 비교 조건을 상세하게 지정할 때 활용. 비교 조건은 클로저로 전달. 클로저는 두 개의 요소를 비교한 결과를 Bool로 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  if alphabet.elementsEqual(lower, by: { $0.lowercased() == $1.lowercased()}) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet == lower
  ```



#### 3.5 새로운 요소 추가

- NSMutableArray

  - add(_: ) : 새로운 요소를 배열의 마지막에 추가
  - insert(_: at: ) : 원하는 위치에 새로운 요소를 추가

  ```swift
  let alphabet = NSMutableArray()
  alphabet.add("B")
  print(alphabet)
  // ["B"]
  
  alphabet.insert("A", at:0)
  print(alphabet)
  // ["A", "B"]
  ```

- Array (var로 선언된)

  - append(_: ) : NSMutableArray의 add()와 동일
  - insert(_: at: ) : NSMutableArray의 insert()와 동일

  ```swift
  var alphabet = [String]()
  alphabet.append("B")
  print(alphabet)
  // ["B"]
  
  alphabet.insert("A", at:0)
  print(alphabet)
  // ["A", "B"]
  ```



#### 3.6 요소 교체

- 특정 요소 교체

  - NSMutableArray - replaceObject(at: with: ) 메소드 또는 서브 스크립트 문법을 이용
  - Array - 서브 스트립트 문법만 사용 가능

  ```swift
  let alphabet = NSMutableArray(array: ["A", "B", "C"])
  alphabet.replaceObject(at: 0, with: "Z")
  print(alphabet)
  // ["Z", "B", "C"]
  
  alphabet[0] = "Y"
  print(alphabet)
  // ["Y", "B", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet[0] = "Z"
  print(alphabet)
  // ["Z", "B", "C"]
  ```

- 특정 범위의 요소들 교체

  - NSMutableArray - replaceObjects(range: with: ) 메소드 제공
  - Array - replaceRange(_: with: ) 메소드를 제공. 범위는 범위 연산자의 활용이 가능

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C"])
  let range = NSRange(location:0, length:2)
  alphabet.replaceObjects(in: range, withObjectsFrom: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet.replaceSubrange(0..<2, with: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

- 컴파일 시점에 정확한 범위를 파악할 수 없는 경우에는 startIndex, endIndex속성을 활용하여 범위를 구하는 것이 안전

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet.replaceSubrange(alphabet.startIndex..<alphabet.endIndex.advanced(by: -1), with: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet[alphabet.startIndex..<alphabet.endIndex.advanced(by: -1)] = ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

- 모든 요소 교체 / 빈 배열로 초기화

  - NSMutableArray - setArray(_: ) 메소드 제공. 빈 배열로 초기화시 파라미터에 빈 배열 전달
  - Array - 무조건 새로운 배열을 할당

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C"])
  alphabet.setArray(["K", "R"])
  print(alphabet)
  // ["K", "R"]
  
  alphabet.setArray([])
  print(alphabet)
  // [] 빈 배열
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet = ["K", "R"])
  print(alphabet)
  // ["K", "R"]
  
  alphabet = []
  print(alphabet)
  // [] 빈 배열
  ```



#### 3.7 요소 삭제

- NSMutableArray

  - removeObject(at: ) : 특정 인덱스의 요소를 삭제할 때 사용
  - removeObjects(in: ) : 삭제할 요소의 범위를 지정할 때 사용

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.removeObject(at: 0)
  print(alphabet)
  // ["B", "C", "D", "E"]
  
  alphabet.removeObjects(in: NSMakeRange(0, 3))
  print(alphabet)
  // ["E"]
  ```

  - removeLastObject() : 배열의 마지막 요소를 삭제
  - removeFirstObject()는 제공하지 않음
  - removeAllObjects() : 배열에 포함된 모든 요소를 삭제

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.removeLastObject()
  print(alphabet)
  // ["A", "B", "C", "D"]
  
  alphabet.removeAllObjects()
  print(alphabet)
  // []
  ```

  - remove(_: ) : 삭제할 요소를 특정할 수 있을 때 사용. 전달된 요소가 배열에 존재하지 않을 경우 아무런 동작을 하지 않아서 안전함

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.remove("C")
  print(alphabet)
  // ["A", "B", "D", "E"]
  ```

  - remove(_: in: ) : 비교할 요소의 범위를 한정해야 할 때 사용

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.remove("C", in:NSMakeRange(0,2))
  print(alphabet)
  // ["A", "B", "C", "D", "E"]
  ```

- Array

  - remove(at: ) : 지정된 인덱스의 요소를 삭제하고 삭제된 요소를 리턴

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  let removed = alphabet.remove(at: 0)
  print(removed)
  // A
  
  print(alphabet)
  // [B", "C", "D", "E"]
  ```

  - removeFirst() : 첫 번째 인덱스의 요소를 삭제하고 삭제된 요소를 리턴. 파라미터를 통해 첫 번째 요소부터 n개의 요소 삭제 가능
  - removeLast() : 마지막 인덱스의 요소를 삭제하고 삭제된 요소를 리턴. 파라미터를 통해 마지막 요소부터 n개의 요소 삭제 가능

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  let first = alphabet.removeFirst()
  print(first)
  // A
  
  print(alphabet)
  // ["B", "C", "D", "E"]
  
  alphabet.removeFirst(2)
  print(alphabet)
  // ["D", "E"]
  
  let last = alphabet.removeLast()
  print(last)
  // E
  
  print(alphabet)
  // ["D"]
  ```

  - popLast() : 배열의 길이를 판단할 수 없는 상황에서 마지막 요소를 삭제하려 할 때 사용. 삭제된 요소를 옵셔널로 리턴. 삭제할 요소가 없는 경우 nil 리턴

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  if let last = alphabet.popLast() {
  	print(last)
  	// E    
  }
  print(alphabet)
  // ["A", "B", "C", "D"]
  ```

  - removeAll(keepingCapacity: ) : 배열에 포함된 모든 요소와 저장 공간을 삭제할 때 사용. 삭제후 새로운 요소를 채우는 경우, keeping Capacity 파라미터를 true로 전달하여 저장 공간을 그대로 유지가능. 불필요한 저장 공간의 할당과 해제가 일어나지 않아 성능향상에 도움됨

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  alphabet.removeAll(keepingCapacity: true)
  print(alphabet)
  // []
  ```

  

#### 3.8 정렬

- NSArray

  - sortedArray(using: ) : 파라미터로 전달된 셀렉터를 사용하여 정렬된 새로운 배열을 리턴
  - sort(using: ) : 새로운 배열을 만들지 않고, 저장된 요소들을 정렬

  ```swift
  let alphabet = NSMutableArray(array: ["A", "B", "C", "a", "b", "c"])
  for i in 0..<(alphabet.count-1) {
      let j = Int(arc4random_uniform(UInt32(alphabet.count-1))) + i
      swap(&alphabet[i], &alphabet[j])
  }
  print(alphabet)
  // ["C", "b", "a", "c", "B", "A"]
  
  let sortedArray = alphabet.sortedArray(using:#selector(NSString.caseInsensitiveCompare(_:)))
  print(sortedArray)
  // ["a", "A", "B", "b", "C", "c"]
  
  alphabet.sort(using: #selector(NSString.caseInsensitiveCompare(_:)))
  print(alphabet)
  // ["a", "A", "B", "b", "C", "c"]
  ```

  - 클로저의 사용 가능

  ```swift
  let alphabet = NSMutableArray(array: ["C", "b", "a", "c", "B", "A"])
  
  let sortedArray = alphabet.sortedArray(comparator:{(obj1, obj2) -> ComparisonResult in 
      return (obj1 as! String).caseInsensitiveCompare(obj2 as! String)
                                                    })
  print(sortedArray)
  // ["a", "A", "B", "b", "C", "c"]
  
  alphabet.sort(comparator: { (obj1, obj2) -> ComparisonResult in
      return (obj1 as! String).caseInsensitiveCompare(obj2 as! String)
                            })
  print(alphabet)
  // ["a", "A", "B", "b", "C", "c"]
  ```

  - Sort Descriptor는 요소를 정렬할 때 기준이 되는 대상 또는 속성을 지정하여 NSSortDescriptor 클래스를 통해 사용할 수 있음. 배열에 KVC를 지원하는 요소가 저장되어 있을 때 오름차순 또는 내림차순으로 정렬하는 코드를 쉽게 작성 가능

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  for i in 0..<(alphabet.count-1) {
      let j = Int(arc4random_uniform(UInt32(alphabet.count-1))) + i
      swap(&alphabet[i], &alphabet[j])
  }
  print(alphabet)
  // ["B", "E", "C", "A", "D"]
  
  let asc = NSSortDescriptor(key: "self", ascending: true)
  var sortedArray = alphabet.sortedArray(using: [asc])
  print(sortedArray)
  // ["A", "B", "C", "D", "E"]
  
  let desc = NSSortDescriptor(key: "self", ascending: false)
  sortedArray = alphabet.sortedArray(using: [desc])
  print(sortedArray)
  // ["E", "D", "C", "B", "A"]
  ```

- Array

  - sort() : 정렬된 새로운 배열을 리턴
  - sorted() : 배열에 포함된 요소를 정렬

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  for i in 0..<(alphabet.count-1) {
      let j = Int(arc4random_uniform(UInt32(alphabet.count-1))) + i
      guard i != j else { continue }
      alphabet.swapAt(i, j)
  }
  print(alphabet)
  // ["B", "E", "D", "C", "A"]
  
  let sortedArray = alphabet.sorted()
  print(sortedArray)
  // ["A", "B", "C", "D", "E"]
  
  alphabet.sort()
  print(alphabet)
  // ["A", "B", "C", "D", "E"]
  ```

  - 클로저 사용 가능

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  for i in 0..<(alphabet.count-1) {
      let j = Int(arc4random_uniform(UInt32(alphabet.count-1))) + i
      guard i != j else { continue }
      alphabet.swapAt(i, j)
  }
  print(alphabet)
  // ["B", "E", "D", "C", "A"]
  
  let sortedArray = alphabet.sorted { $0 > $1 }
  print(sortedArray)
  // ["E", "D", "C", "B", "A"]
  
  alphabet.sort { $0 > $1 }
  print(alphabet)
  // ["E", "D", "C", "B", "A"]
  ```

  - reversed() : 역순 정렬시 사용. 리턴 값은 형식 추론을 통해 ReverseRandomAccessCollection이 되기 때문에 자료형을 직접 지정해 주거나 생성자에 전달하면 별도의 형변환 없이 역순으로 정렬된 배열 획득 가능

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  var result = alphabet.reversed()
  print(alphabet)
  // ReverseRandomAccessCollection<Array<String>>(_base: ["E", "D", "C", "B", "A"])
  
  var result2: [String] = alphabet.reversed()
  print(result2)
  // ["E", "D", "C", "B", "A"]
  
  var result2 = [String](alphabet.reversed())
  print(result2)
  // ["E", "D", "C", "B", "A"]
  ```

  

#### 3.9 범위 추출

- 특정 범위에 있는 요소들을 새로운 배열로 추출하려는 경우 사용

  - (NSArray) subarray(with: )

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let subArray = alphabet.subarray(with:NSMakeRange(1, 3))
  print(subArray)
  // ["B", "C", "D"]
  ```

  - (Array) 서브스크립트 문법과 범위 연산자를 조합하여 배열 추출

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let subArray = alphabet[1..<4]
  print(subArray)
  // ["B", "C", "D"]
  ```

- dropFirst() : 배열의 첫번째 요소를 제외한 나머지 요소를 새로운 배열로 리턴

- dropFirst(_: ) : 전달된 정수 파라미터 n개의 요소를 앞에서부터 제외한 나머지 요소의 배열이 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  let result = alphabet.dropFirst()
  print(result)
  // ["B", "C", "D", "E"]
  
  result = alphabet.dropFirst(3)
  print(result)
  // ["D", "E"]
  ```

- dropLast() : 배열의 마지막 요소를 제외한 나머지 요소를 새로운 배열로 리턴

- dropLast(_: ) : 전달된 정수 파라미터 n개의 요소를 뒤에서부터 제외한 나머지 요소의 배열이 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  let result = alphabet.dropLast()
  print(result)
  // ["A", "B", "C", "D"]
  
  result = alphabet.dropLast(3)
  print(result)
  // ["A", "B"]
  ```

- prefix(_: ) : 전달된 정수 파라미터 n개의 요소를 앞에서부터 추출하여 새로운 배열을 리턴

- prefix(upTo: ) : 첫번째 요소부터 전달된 정수 파라미터인 지정된 인덱스 이전까지의 요소를 추출하여 새로운 배열을 리턴

- prefix(through: ) : prefix(upTo: )와 비슷하지만 전달된 파라미터인 지정된 인덱스 까지의 요소를 추출

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  let result = alphabet.prefix(2)
  print(result)
  // ["A", "B"]
  
  result = alphabet.prefix(upTo: 2)
  print(result)
  // ["A", "B"]
  
  result = alphabet.prefix(through: 2)
  print(result)
  // ["A", "B", "C"]
  ```

- suffix(_: ) : 전달된 정수 파라미터 n개의 요소를 뒤에서부터 추출하여 새로운 배열을 리턴

- suffix(from: ) : 전달된 정수 파라미터인 지정된 인덱스부터 마지막 요소까지 추출하여 새로운 배열을 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  let result = alphabet.suffix(2)
  print(result)
  // ["D", "E"]
  
  result = alphabet.suffix(from: 2)
  print(result)
  // ["C", "D", "E"]
  ```




#### 3.10 배열 변환

- 병합 - 배열에 저장된 요소들을 파라미터로 전달한 분리자로 연결한 문자열을 리턴

  - (NSArray) componentJoined(by: ) 
  - (Array) joined(separator: )

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let str = alphabet.componentJoined(by: "#")
  
  print(str)
  // A#B#C#D#E
  ```

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let str = alphabet.joined(separator: "#")
  
  print(str)
  // A#B#C#D#E
  ```

- map(_: ) : Array배열의 모든 요소를 순회하면서 파라미터로 전달한 클로저를 실행한 결과값을 포함하고 있는 새로운 배열을 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let result = alphabet.map { $0.lowercased() }
  
  print(result)
  // ["a", "b", "c", "d", "e"]
  ```

  

#### 3.11 Array 배열의 메모리 공간과 최적화

- 배열은 초기화에 사용된 요소의 수에 따라 최초 저장 공간의 크기가 결정

- 요소를 추가할 공간이 부족할 경우, 새로운 저장 공간을 할당할 때, 이전의 2배 크기의 공간을 할당 (Exponential Growth Strategy)

- 필요한 저장 공간의 크기를 미리 예측 가능하다면, reserveCapacity(_: ) 메소드를 통해 원하는 저장 공간 할당 가능. 해당 메소드로 할당되는 공간의 크기는 파라미터로 전달한 크기보다 크거나 같음.

  ```swift
  var list = ["A", "B", "C"]
  print("total: \(list.capacity), current: \(list.count)")
  // total: 3, current: 3
  
  list += ["D"]
  print("total: \(list.capacity), current: \(list.count)")
  // total: 6, current: 4
  
  list += ["E", "F", "G", "H", "I"]
  print("total: \(list.capacity), current: \(list.count)")
  // total: 12, current: 9
  
  list[1..<6] = ["A"]
  print("total: \(list.capacity), current: \(list.count)")
  // total: 12, current: 5
  
  var reservedList = [String]()
  reservedList.reserveCapacity(100)
  print("total: \(reservedList.capacity), current: \(reservedList.count)")
  // total: 105, current: 0
  ```



### 4. 딕셔너리

- Key-value쌍으로 순서없이 저장하는 컬렉션

  ```swift
  [키1:값1, 키2:값2, 키3:값3, ..., 키N:값N]
  [:] // 빈 딕셔너리
  ```

  ```swift
  // 딕셔너리의 자료형 표현 방식
  Dictionary<키의 자료형, 값의 자료형> 
  [키의 자료형: 값의 자료형] // 단축 문법
  ```

  

- Swift에서 빈 딕셔너리로 초기화하는 경우에는 반드시 키와 값의 자료형을 지정해야 함

  ```swift
  // Swift Dictionary
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
   
  // Foundation Dictionary
  let nsWords: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  ```

  ```swift
  // 빈 배열 선언
  // Foundation Dictionary
  let emptyNSDict = NSMutableDictionary()
  
  // Swift Dictionary
  var emptyWordDict1: Dictionary<String, String> = [:]
  var emptyWordDict2: [String: String] = [:]
  var emptyWordDict3 = [String: String]()
  ```

  

#### 4.1 배열에 포함된 요소의 수

- 요소의 수는 count속성으로 확인 가능

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  let countOfWords = words.count
  
  if countOfWords > 0 {
      print("\(countOfWords) element(s)")
  } else {
      print("empty dictionary")
  }
  // 3 element(s)
  ```

- 딕셔너리가 비어 있는지 확인하기 위해 isEmpty속성 사용 가능

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  let countOfWords = words.count
  
  if !words.isEmpty {
      print("\(countOfWords) element(s)")
  } else {
      print("empty dictionary")
  }
  // 3 element(s)
  ```



#### 4.2 요소에 접근

- 요소에 접근할 때 키를 전달하면 키와 연관된 값을 읽거나 변경 가능

- NSDictionary - object(forKey: ) 메소드를 제공

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  let aValue = words.object(forKey:"A")
  
  print(aValue)
  // Optional(Apple)
  
  let zValue = words.object(forKey:"Z")
  print(zValue)
  // nil
  ```

  - 배열의 경우 존재하지 않는(범위 밖) 인덱스를 전달할 경우 런타임 오류가 발생하지만 딕셔너리는 존재하니 않는 키를 전달해도 런타임 오류가 발생하지 않음

    

- Swift는 주로 옵셔널 바인딩 구문과 결합해서 사용

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  
  if let aValue = words.object(forKey:"A") {
      // ...
  } 
  ```

  

- 배열과 마찬가지로 요소 접근시 서브스크립트 문법 사용 가능. 배열의 문법과 동일하지만 인덱스 대신 키를 전달

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  
  if let aValue = words["A"]) {
      print(aValue)
  } else {
      print("Not found")
  }
  // Apple
  
  if let zValue = words["Z"]) {
      print(zValue)
  } else {
      print("Not found")
  }
  // Not found
  ```

  

- Swift 4부터는 서브스크립트로 기본값 전달 가능

  ```swift
  [키, default:기본값]
  ```

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  
  words["A"]
  // Apple
  
  words["Z"]
  // nil
  
  words["z", default: "No Words"]
  // No Words
  ```



#### 4.3 키, 값 검색















- NSArray

  - contains(_: ) : 파라미터로 전달된 객체가 NSArray  배열에 포함되어 있는지 확인

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
    
  if alphabet.contains("A") {
      print("contains A")
  }
  // contains A
  ```


  - index(of: ) : 특정 요소의 인덱스를 파악하고 싶을 때 사용. 배열에 전달된 요소가 포함되어 있다면 해당 요소의 인덱스가 리턴되고, 포함되어 있지 않다면 NSNotFound가 리턴

  ```swift
let alphabet: NSArray = ["A", "B", "C", "D", "E"]
let index = alphabet.index(of: "C")
  
if index != NSNotFound {
    print("index of C: \(index)")
}
// index of C: 2
  ```

  - filteredArrayUsingPredicate(_: ) : 검색 조건을 지정하여 조건과 일치하는 요소를 파악하고 싶을 때 사용. 검색 조건을 지정하는 NSPredicate 객체를 통해 요소를 비교한 후 조건이 일치하는 요소들을 새로운 배열로 리턴. NSMutableArray 역시 유사한 메소드를 제고하는데 가변 배열의 특성상 새로운 배열을 리턴하지 않고 현재 배열에 포함된 요소 중 조건이 일치하는 요소를 제외한 나머지 요소를 삭제함

  ```swift
let productNams: NSArray = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
let prefixPredicate = NSPredicate(format: "SELF BEGINSWITH %@", "i")
let filteredArray = productNames.filtered(using: prefixPredicate)

print(filteredArray)
// ["iPhone", "iPad", "iPad Pro"]

let mutableProductNames = NSMutableArray(array: productNames)
let suffixPredicate = NSPredicate(format: "SELF ENDSWITH %@", "o")
mutableProductNames.filter(using: suffixPredicate)

print(mutableProductNames)
// ["Mac Pro", "iPad Pro", "Macbook Pro"]
  ```

- Array

  - contains(_:) : 지정된 요소가 포함되어 있는지 확인하는 메소드. 클로저를 통해 검색 조건을 더욱 상세하게 구현 가능

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  if alphabet.contains("C") {
      print("contains C")
  }
  // contains C
  
  if alphabet.contains(where: { $0 == "A"}) {
      print("contains A")
  }
  // contains A
  ```

  - indexOf(_: ) :  파라미터로 전달된 요소의 인덱스를 옵셔널로 리턴. 배열에 존재하지 않으면 nil을 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let index = alphabet.index(of: "C")
    
  if let index = alphabet.index(of: "C") {
      print("index of C: \(index)")
  }
  // index of C: 2
  ```

  - Array는 NSArray와 달리 클로저를 통해 검색 조건을 구현함

  ```swift
  let productNams = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
  let filteredArray = productNames.filter { (element) -> Bool in
      return element.hasPrefix("i")
  }
  print(filteredArray)
  // ["iPhone", "iPad", "iPad Pro"]
  ```





#### 4.4 딕셔너리 비교



#### 4.5 새로운 요소 추가와 교체



#### 4.6 요소 삭제





#### 3.3 요소 검색

#### 3.4 배열 비교

- 두 배열이 동일한 배열인지 판단하는 두가지 조건. 

  - 요소의 순서
  - isEqual(_: ) 메소드의 결과(NSArray) 또는 == 연산자로 비교한 결과(Array)

- NSArray

  - isEqual(to: ) : 요소에 저정된 순서와 대소문자가 완전히 일치하는 경우에만 같은 배열로 판단.

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let upper = ["A", "B", "C", "D", "E"]
  let shuffled = ["E", "B", "C", "A", "D"]
  let lower = ["a", "b", "c", "d", "e"]
  let mixed = ["A", "b", "C", "d", "e"]
  
  if alphabet.isEqual(to: upper) {
      print("alphabet == upper")
  } else {
      print("alphabet != upper")
  }
  
  if alphabet.isEqual(to: shuffled) {
      print("alphabet == shuffled")
  } else {
      print("alphabet != shuffled")
  }
  
  if alphabet.isEqual(to: lower) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  
  if alphabet.isEqual(to: mixed) {
      print("alphabet == mixed")
  } else {
      print("alphabet != mixed")
  }
  
  // alphabet == upper
  // alphabet != shuffled
  // alphabet != lower
  // alphabet != mixed
  ```

  - isEqual(to: )의 결과로 인해 원하는 결과를 얻을 수 없다면 배열의 모든 요소를 열거하면서 두 배열에 포함된 요소를 비교하는 코드를 직접 구현해야 함.

  ```swift
  // 대소문자에 관계없이 비교
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  var equal = true
  if alphabet.count == lower.count {
      for i in 0..<alphabet.count {
          let lhs = alphabet[i] as! NSString
          let rhs = lower[i]
          
          if lhs.caseInsensitiveCompare(rhs) != .orderSame {
              equal = false
              break
          }
      }
  }
  
  if alphabet.isEqual(to: lower) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet == lower
  ```

- Array

  - elementsEqual(_: ) : 요소의 순서가 동일하고 두 요소를 == 연산자로 비교한 결과가 true인 경우에만 동일 배열로 판단. Swift는 ==연산자로 요소뿐만 아니라 배열 자체를 비교할 수 있음

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  if alphabet == lower {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet != lower
  ```

  - elementsEqual(_: by: ) : 요소의 비교 조건을 상세하게 지정할 때 활용. 비교 조건은 클로저로 전달. 클로저는 두 개의 요소를 비교한 결과를 Bool로 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  if alphabet.elementsEqual(lower, by: { $0.lowercased() == $1.lowercased()}) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet == lower
  ```



#### 3.5 새로운 요소 추가

- NSMutableArray

  - add(_: ) : 새로운 요소를 배열의 마지막에 추가
  - insert(_: at: ) : 원하는 위치에 새로운 요소를 추가

  ```swift
  let alphabet = NSMutableArray()
  alphabet.add("B")
  print(alphabet)
  // ["B"]
  
  alphabet.insert("A", at:0)
  print(alphabet)
  // ["A", "B"]
  ```

- Array (var로 선언된)

  - append(_: ) : NSMutableArray의 add()와 동일
  - insert(_: at: ) : NSMutableArray의 insert()와 동일

  ```swift
  var alphabet = [String]()
  alphabet.append("B")
  print(alphabet)
  // ["B"]
  
  alphabet.insert("A", at:0)
  print(alphabet)
  // ["A", "B"]
  ```



#### 3.6 요소 교체

- 특정 요소 교체

  - NSMutableArray - replaceObject(at: with: ) 메소드 또는 서브 스크립트 문법을 이용
  - Array - 서브 스트립트 문법만 사용 가능

  ```swift
  let alphabet = NSMutableArray(array: ["A", "B", "C"])
  alphabet.replaceObject(at: 0, with: "Z")
  print(alphabet)
  // ["Z", "B", "C"]
  
  alphabet[0] = "Y"
  print(alphabet)
  // ["Y", "B", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet[0] = "Z"
  print(alphabet)
  // ["Z", "B", "C"]
  ```

- 특정 범위의 요소들 교체

  - NSMutableArray - replaceObjects(range: with: ) 메소드 제공
  - Array - replaceRange(_: with: ) 메소드를 제공. 범위는 범위 연산자의 활용이 가능

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C"])
  let range = NSRange(location:0, length:2)
  alphabet.replaceObjects(in: range, withObjectsFrom: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet.replaceSubrange(0..<2, with: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

- 컴파일 시점에 정확한 범위를 파악할 수 없는 경우에는 startIndex, endIndex속성을 활용하여 범위를 구하는 것이 안전

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet.replaceSubrange(alphabet.startIndex..<alphabet.endIndex.advanced(by: -1), with: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet[alphabet.startIndex..<alphabet.endIndex.advanced(by: -1)] = ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

- 모든 요소 교체 / 빈 배열로 초기화

  - NSMutableArray - setArray(_: ) 메소드 제공. 빈 배열로 초기화시 파라미터에 빈 배열 전달
  - Array - 무조건 새로운 배열을 할당

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C"])
  alphabet.setArray(["K", "R"])
  print(alphabet)
  // ["K", "R"]
  
  alphabet.setArray([])
  print(alphabet)
  // [] 빈 배열
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet = ["K", "R"])
  print(alphabet)
  // ["K", "R"]
  
  alphabet = []
  print(alphabet)
  // [] 빈 배열
  ```



#### 3.7 요소 삭제

- NSMutableArray

  - removeObject(at: ) : 특정 인덱스의 요소를 삭제할 때 사용
  - removeObjects(in: ) : 삭제할 요소의 범위를 지정할 때 사용

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.removeObject(at: 0)
  print(alphabet)
  // ["B", "C", "D", "E"]
  
  alphabet.removeObjects(in: NSMakeRange(0, 3))
  print(alphabet)
  // ["E"]
  ```

  - removeLastObject() : 배열의 마지막 요소를 삭제
  - removeFirstObject()는 제공하지 않음
  - removeAllObjects() : 배열에 포함된 모든 요소를 삭제

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.removeLastObject()
  print(alphabet)
  // ["A", "B", "C", "D"]
  
  alphabet.removeAllObjects()
  print(alphabet)
  // []
  ```

  - remove(_: ) : 삭제할 요소를 특정할 수 있을 때 사용. 전달된 요소가 배열에 존재하지 않을 경우 아무런 동작을 하지 않아서 안전함

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.remove("C")
  print(alphabet)
  // ["A", "B", "D", "E"]
  ```

  - remove(_: in: ) : 비교할 요소의 범위를 한정해야 할 때 사용

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.remove("C", in:NSMakeRange(0,2))
  print(alphabet)
  // ["A", "B", "C", "D", "E"]
  ```

- Array

  - remove(at: ) : 지정된 인덱스의 요소를 삭제하고 삭제된 요소를 리턴

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  let removed = alphabet.remove(at: 0)
  print(removed)
  // A
  
  print(alphabet)
  // [B", "C", "D", "E"]
  ```

  - removeFirst() : 첫 번째 인덱스의 요소를 삭제하고 삭제된 요소를 리턴. 파라미터를 통해 첫 번째 요소부터 n개의 요소 삭제 가능
  - removeLast() : 마지막 인덱스의 요소를 삭제하고 삭제된 요소를 리턴. 파라미터를 통해 마지막 요소부터 n개의 요소 삭제 가능

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  let first = alphabet.removeFirst()
  print(first)
  // A
  
  print(alphabet)
  // ["B", "C", "D", "E"]
  
  alphabet.removeFirst(2)
  print(alphabet)
  // ["D", "E"]
  
  let last = alphabet.removeLast()
  print(last)
  // E
  
  print(alphabet)
  // ["D"]
  ```

  - popLast() : 배열의 길이를 판단할 수 없는 상황에서 마지막 요소를 삭제하려 할 때 사용. 삭제된 요소를 옵셔널로 리턴. 삭제할 요소가 없는 경우 nil 리턴

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  if let last = alphabet.popLast() {
  	print(last)
  	// E    
  }
  print(alphabet)
  // ["A", "B", "C", "D"]
  ```

  - removeAll(keepingCapacity: ) : 배열에 포함된 모든 요소와 저장 공간을 삭제할 때 사용. 삭제후 새로운 요소를 채우는 경우, keeping Capacity 파라미터를 true로 전달하여 저장 공간을 그대로 유지가능. 불필요한 저장 공간의 할당과 해제가 일어나지 않아 성능향상에 도움됨

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  alphabet.removeAll(keepingCapacity: true)
  print(alphabet)
  // []
  ```

  
