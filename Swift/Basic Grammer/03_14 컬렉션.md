# 컬렉션


- 데이터의 모음을 쉽게 처리하기 위해 사용하는 특별한 자료형(Array, Dictionary, Set, ...)
      - Array - 데이터를 순서대로 저장하는 컬렉션
      - Dictionary - Key/Value 페어로 저장하는 컬렉션
      - Set - 집합 연산을 편리하게 수행할 수 있는 컬렉션

    - Foundation 프레임워크에서 제공하는 컬렉션 클래스와  Swift Standard Library에서 제공하는 컬렉션 구조체를 모두 사용 가능
      - Foundation 컬렉션 - 저장요소가 객체로 제한(값 형식 저장 불가. 객체로 박싱 후 저장 가능). 저장하는 자료형의 제한이 없어 서로 다른 자료형의 객체를 하나의 컬렉션에서 저장 가능
      - Swift 컬렉션 - 참조형식, 값 형식 모두 저장 가능(값 형식 박싱없이 저장 가능). 저장할 요소의 자료형을 선언 시점에 명시적으로 지정해야 함.(서로 다른 자료형의 데이터 저장 불가)


​    

### 1. 컬렉션의 가변성

|                   |    불변형    |       가변형        |
| :---------------: | :----------: | :-----------------: |
| Foundation 컬렉션 |   NSArray    |   NSMutableArray    |
|                   | NSDictionary | NSMutableDIctionary |
|                   |    NSSet     |    NSMutableSet     |
|   Swift 컬렉션    | let으로 선언 |     var로 선언      |

- 가변형과 불변형의 구분은 스레드 안정성에서 큰 이점을 가짐

- 컬렉션 생성 후, 수정할 필요가 없는 경우 항상 불변 컬렉션을 사용하는 것을 추천

​      

### 2. Swift 컬렉션 최적화

- Swift 컬렉션은 모두 구조체로 구현된 값 형식임. 값 사용시 복사 작업 수행필요.
- 컬렉션 자료형은 데이터의 크기가 크기 때문에 무조건 복사 작업을 수행하는 것은 성능을 저하시킴
- 단점 극복을 위해 문자열과 마찬가지로 복사가 필요한 경우에만 실제 복사를 수행하도록 최적화함
  - 한 배열을 다른 변수에 할당시,즉시 복사가 발생하는 것이 아니라 다른 변수에서 값의 수정이 발생하는 경우에 복사 수행을 함



### 3. 배열

- 요소를 순서대로 정렬하는 컬렉션

  ```swift
  [요소1, 요소2, 요소3, ..., 요소N]
  [] // 빈 배열
  ```

  ```swift
  // 배열의 자료형 표현 방식
  Array<요소의 자료형> 
  [요소의 자료형] // 단축 문법
  ```

- Swift에서 빈 배열을 생성할 때는 형식 추론에 필요한 정보가 없기 때문에, 반드시 배열에 저장할 자료형을 지정해야 함

  ```swift
  // Swift Array
  let stringArray = ["Apple", "Orange", "Banana"]
  
  // Foundation Array
  let stringNSArray: NSArray = ["Apple", "Orange", "Banana"]
  ```

  ```swift
  // 생성자를 이용한 선언
  let stringArray = Array(["Apple", "Orange", "Banana"])
  let stringNSArray = NSArray(objects: "Apple", "Orange", "Banana")
  ```

  ```swift
  // 빈 배열 선언
  // Foundation Array
  let emptyArray1: NSMutableArray = []
  let emptyArray2 = NSMutableArray()
  
  // Swift Array
  var emptyStringArray1: Array<String> = []
  var emptyStringArray2 = Array<String>()
  var emptyStringArray3: [String] = []
  var emptyStringArray4 = [String]()
  
  var emptyArray = [] // Error
  ```



#### 3.1 배열에 포함된 요소의 수

- 요소의 수는 count속성으로 확인 가능

- Array 배열의 경우 isEmpty 속성 사용 가능

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  let countOfFruits = fruits.count
  
  if !fruits.isEmpty {
      print("\(countOfFruits) element(s)")
  } else {
      print("empty array")
  }
  // 3 element(s)
  ```



#### 3.2 요소에 접근

- 정수 인덱스로 요소에 접근. 인덱스는 배열이 제공하는 메소드 또는 서브스크립트 문법으로 전달

- NSArray - object(at: ) 메소드를 제공

  ```swift
  let fruits: NSArray = ["Apple", "Orange", "Banana"]
  let first = fruits.object(at: 0)
  let last = fruits.object(at: fruits.count -1)
  
  print(first)
  print(last)
  // Apple
  // Banana
  ```

  ```swift
  let fruits: NSArray = ["Apple", "Orange", "Banana"]
  let first = fruits[0]
  let last = fruits[fruits.count -1]
  ```

- Array - startIndex, endIndex 속성을 제공

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  let index = 100
  if index >= fruits.startIndex && index < fruits.endIndex {
      // ...
  }
  ```

- 배열은 첫번째 요소와 마지막 요소에 접근할 수 있는 특별한 속성을 제공

  - NSArray - firstObject, lastObject
  - Array - first, last
  - 배열이 비어있는 경우 nil을 리턴하므로 값을 사용하기 전에 유효한 값이 리턴되었는지 확인 필요

  ```swift
  let fruits = ["Apple", "Orange", "Banana"]
  
  if let first = fruits.first {
      // ...
  }
  
  if let last = fruits.last {
      // ...
  }
  ```



#### 3.3 요소 검색

- NSArray

  - contains(_: ) : 파라미터로 전달된 객체가 NSArray  배열에 포함되어 있는지 확인

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
    
  if alphabet.contains("A") {
      print("contains A")
  }
  // contains A
  ```

    - index(of: ) : 특정 요소의 인덱스를 파악하고 싶을 때 사용. 배열에 전달된 요소가 포함되어 있다면 해당 요소의 인덱스가 리턴되고, 포함되어 있지 않다면 NSNotFound가 리턴

    ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let index = alphabet.index(of: "C")
    
  if index != NSNotFound {
      print("index of C: \(index)")
  }
  // index of C: 2
    ```

    - filteredArrayUsingPredicate(_: ) : 검색 조건을 지정하여 조건과 일치하는 요소를 파악하고 싶을 때 사용. 검색 조건을 지정하는 NSPredicate 객체를 통해 요소를 비교한 후 조건이 일치하는 요소들을 새로운 배열로 리턴. NSMutableArray 역시 유사한 메소드를 제고하는데 가변 배열의 특성상 새로운 배열을 리턴하지 않고 현재 배열에 포함된 요소 중 조건이 일치하는 요소를 제외한 나머지 요소를 삭제함

    ```swift
  let productNams: NSArray = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
  let prefixPredicate = NSPredicate(format: "SELF BEGINSWITH %@", "i")
  let filteredArray = productNames.filtered(using: prefixPredicate)
  
  print(filteredArray)
  // ["iPhone", "iPad", "iPad Pro"]
  
  let mutableProductNames = NSMutableArray(array: productNames)
  let suffixPredicate = NSPredicate(format: "SELF ENDSWITH %@", "o")
  mutableProductNames.filter(using: suffixPredicate)
  
  print(mutableProductNames)
  // ["Mac Pro", "iPad Pro", "Macbook Pro"]
    ```

- Array

  - contains(_:) : 지정된 요소가 포함되어 있는지 확인하는 메소드. 클로저를 통해 검색 조건을 더욱 상세하게 구현 가능

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  if alphabet.contains("C") {
      print("contains C")
  }
  // contains C
  
  if alphabet.contains(where: { $0 == "A"}) {
      print("contains A")
  }
  // contains A
  ```

  - indexOf(_: ) :  파라미터로 전달된 요소의 인덱스를 옵셔널로 리턴. 배열에 존재하지 않으면 nil을 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let index = alphabet.index(of: "C")
    
  if let index = alphabet.index(of: "C") {
      print("index of C: \(index)")
  }
  // index of C: 2
  ```

  - Array는 NSArray와 달리 클로저를 통해 검색 조건을 구현함

  ```swift
  let productNams = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
  let filteredArray = productNames.filter { (element) -> Bool in
      return element.hasPrefix("i")
  }
  print(filteredArray)
  // ["iPhone", "iPad", "iPad Pro"]
  ```



#### 3.4 배열 비교

- 두 배열이 동일한 배열인지 판단하는 두가지 조건. 

  - 요소의 순서
  - isEqual(_: ) 메소드의 결과(NSArray) 또는 == 연산자로 비교한 결과(Array)

- NSArray

  - isEqual(to: ) : 요소에 저정된 순서와 대소문자가 완전히 일치하는 경우에만 같은 배열로 판단.

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let upper = ["A", "B", "C", "D", "E"]
  let shuffled = ["E", "B", "C", "A", "D"]
  let lower = ["a", "b", "c", "d", "e"]
  let mixed = ["A", "b", "C", "d", "e"]
  
  if alphabet.isEqual(to: upper) {
      print("alphabet == upper")
  } else {
      print("alphabet != upper")
  }
  
  if alphabet.isEqual(to: shuffled) {
      print("alphabet == shuffled")
  } else {
      print("alphabet != shuffled")
  }
  
  if alphabet.isEqual(to: lower) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  
  if alphabet.isEqual(to: mixed) {
      print("alphabet == mixed")
  } else {
      print("alphabet != mixed")
  }
  
  // alphabet == upper
  // alphabet != shuffled
  // alphabet != lower
  // alphabet != mixed
  ```

  - isEqual(to: )의 결과로 인해 원하는 결과를 얻을 수 없다면 배열의 모든 요소를 열거하면서 두 배열에 포함된 요소를 비교하는 코드를 직접 구현해야 함.

  ```swift
  // 대소문자에 관계없이 비교
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  var equal = true
  if alphabet.count == lower.count {
      for i in 0..<alphabet.count {
          let lhs = alphabet[i] as! NSString
          let rhs = lower[i]
          
          if lhs.caseInsensitiveCompare(rhs) != .orderSame {
              equal = false
              break
          }
      }
  }
  
  if alphabet.isEqual(to: lower) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet == lower
  ```

- Array

  - elementsEqual(_: ) : 요소의 순서가 동일하고 두 요소를 == 연산자로 비교한 결과가 true인 경우에만 동일 배열로 판단. Swift는 ==연산자로 요소뿐만 아니라 배열 자체를 비교할 수 있음

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  if alphabet == lower {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet != lower
  ```

  - elementsEqual(_: by: ) : 요소의 비교 조건을 상세하게 지정할 때 활용. 비교 조건은 클로저로 전달. 클로저는 두 개의 요소를 비교한 결과를 Bool로 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let lower = ["a", "b", "c", "d", "e"]
  
  if alphabet.elementsEqual(lower, by: { $0.lowercased() == $1.lowercased()}) {
      print("alphabet == lower")
  } else {
      print("alphabet != lower")
  }
  // alphabet == lower
  ```



#### 3.5 새로운 요소 추가

- NSMutableArray

  - add(_: ) : 새로운 요소를 배열의 마지막에 추가
  - insert(_: at: ) : 원하는 위치에 새로운 요소를 추가

  ```swift
  let alphabet = NSMutableArray()
  alphabet.add("B")
  print(alphabet)
  // ["B"]
  
  alphabet.insert("A", at:0)
  print(alphabet)
  // ["A", "B"]
  ```

- Array (var로 선언된)

  - append(_: ) : NSMutableArray의 add()와 동일
  - insert(_: at: ) : NSMutableArray의 insert()와 동일

  ```swift
  var alphabet = [String]()
  alphabet.append("B")
  print(alphabet)
  // ["B"]
  
  alphabet.insert("A", at:0)
  print(alphabet)
  // ["A", "B"]
  ```



#### 3.6 요소 교체

- 특정 요소 교체

  - NSMutableArray - replaceObject(at: with: ) 메소드 또는 서브 스크립트 문법을 이용
  - Array - 서브 스트립트 문법만 사용 가능

  ```swift
  let alphabet = NSMutableArray(array: ["A", "B", "C"])
  alphabet.replaceObject(at: 0, with: "Z")
  print(alphabet)
  // ["Z", "B", "C"]
  
  alphabet[0] = "Y"
  print(alphabet)
  // ["Y", "B", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet[0] = "Z"
  print(alphabet)
  // ["Z", "B", "C"]
  ```

- 특정 범위의 요소들 교체

  - NSMutableArray - replaceObjects(range: with: ) 메소드 제공
  - Array - replaceRange(_: with: ) 메소드를 제공. 범위는 범위 연산자의 활용이 가능

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C"])
  let range = NSRange(location:0, length:2)
  alphabet.replaceObjects(in: range, withObjectsFrom: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet.replaceSubrange(0..<2, with: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

- 컴파일 시점에 정확한 범위를 파악할 수 없는 경우에는 startIndex, endIndex속성을 활용하여 범위를 구하는 것이 안전

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet.replaceSubrange(alphabet.startIndex..<alphabet.endIndex.advanced(by: -1), with: ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet[alphabet.startIndex..<alphabet.endIndex.advanced(by: -1)] = ["X", "Y"])
  
  print(alphabet)
  // ["X", "Y", "C"]
  ```

- 모든 요소 교체 / 빈 배열로 초기화

  - NSMutableArray - setArray(_: ) 메소드 제공. 빈 배열로 초기화시 파라미터에 빈 배열 전달
  - Array - 무조건 새로운 배열을 할당

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C"])
  alphabet.setArray(["K", "R"])
  print(alphabet)
  // ["K", "R"]
  
  alphabet.setArray([])
  print(alphabet)
  // [] 빈 배열
  ```

  ```swift
  var alphabet = ["A", "B", "C"]
  alphabet = ["K", "R"])
  print(alphabet)
  // ["K", "R"]
  
  alphabet = []
  print(alphabet)
  // [] 빈 배열
  ```



#### 3.7 요소 삭제

- NSMutableArray

  - removeObject(at: ) : 특정 인덱스의 요소를 삭제할 때 사용
  - removeObjects(in: ) : 삭제할 요소의 범위를 지정할 때 사용

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.removeObject(at: 0)
  print(alphabet)
  // ["B", "C", "D", "E"]
  
  alphabet.removeObjects(in: NSMakeRange(0, 3))
  print(alphabet)
  // ["E"]
  ```

  - removeLastObject() : 배열의 마지막 요소를 삭제
  - removeFirstObject()는 제공하지 않음
  - removeAllObjects() : 배열에 포함된 모든 요소를 삭제

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.removeLastObject()
  print(alphabet)
  // ["A", "B", "C", "D"]
  
  alphabet.removeAllObjects()
  print(alphabet)
  // []
  ```

  - remove(_: ) : 삭제할 요소를 특정할 수 있을 때 사용. 전달된 요소가 배열에 존재하지 않을 경우 아무런 동작을 하지 않아서 안전함

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.remove("C")
  print(alphabet)
  // ["A", "B", "D", "E"]
  ```

  - remove(_: in: ) : 비교할 요소의 범위를 한정해야 할 때 사용

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  
  alphabet.remove("C", in:NSMakeRange(0,2))
  print(alphabet)
  // ["A", "B", "C", "D", "E"]
  ```

- Array

  - remove(at: ) : 지정된 인덱스의 요소를 삭제하고 삭제된 요소를 리턴

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  let removed = alphabet.remove(at: 0)
  print(removed)
  // A
  
  print(alphabet)
  // [B", "C", "D", "E"]
  ```

  - removeFirst() : 첫 번째 인덱스의 요소를 삭제하고 삭제된 요소를 리턴. 파라미터를 통해 첫 번째 요소부터 n개의 요소 삭제 가능
  - removeLast() : 마지막 인덱스의 요소를 삭제하고 삭제된 요소를 리턴. 파라미터를 통해 마지막 요소부터 n개의 요소 삭제 가능

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  let first = alphabet.removeFirst()
  print(first)
  // A
  
  print(alphabet)
  // ["B", "C", "D", "E"]
  
  alphabet.removeFirst(2)
  print(alphabet)
  // ["D", "E"]
  
  let last = alphabet.removeLast()
  print(last)
  // E
  
  print(alphabet)
  // ["D"]
  ```

  - popLast() : 배열의 길이를 판단할 수 없는 상황에서 마지막 요소를 삭제하려 할 때 사용. 삭제된 요소를 옵셔널로 리턴. 삭제할 요소가 없는 경우 nil 리턴

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  if let last = alphabet.popLast() {
  	print(last)
  	// E    
  }
  print(alphabet)
  // ["A", "B", "C", "D"]
  ```

  - removeAll(keepingCapacity: ) : 배열에 포함된 모든 요소와 저장 공간을 삭제할 때 사용. 삭제후 새로운 요소를 채우는 경우, keeping Capacity 파라미터를 true로 전달하여 저장 공간을 그대로 유지가능. 불필요한 저장 공간의 할당과 해제가 일어나지 않아 성능향상에 도움됨

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  
  alphabet.removeAll(keepingCapacity: true)
  print(alphabet)
  // []
  ```



#### 3.8 정렬

- NSArray

  - sortedArray(using: ) : 파라미터로 전달된 셀렉터를 사용하여 정렬된 새로운 배열을 리턴
  - sort(using: ) : 새로운 배열을 만들지 않고, 저장된 요소들을 정렬

  ```swift
  let alphabet = NSMutableArray(array: ["A", "B", "C", "a", "b", "c"])
  for i in 0..<(alphabet.count-1) {
      let j = Int(arc4random_uniform(UInt32(alphabet.count-1))) + i
      swap(&alphabet[i], &alphabet[j])
  }
  print(alphabet)
  // ["C", "b", "a", "c", "B", "A"]
  
  let sortedArray = alphabet.sortedArray(using:#selector(NSString.caseInsensitiveCompare(_:)))
  print(sortedArray)
  // ["a", "A", "B", "b", "C", "c"]
  
  alphabet.sort(using: #selector(NSString.caseInsensitiveCompare(_:)))
  print(alphabet)
  // ["a", "A", "B", "b", "C", "c"]
  ```

  - 클로저의 사용 가능

  ```swift
  let alphabet = NSMutableArray(array: ["C", "b", "a", "c", "B", "A"])
  
  let sortedArray = alphabet.sortedArray(comparator:{(obj1, obj2) -> ComparisonResult in 
      return (obj1 as! String).caseInsensitiveCompare(obj2 as! String)
                                                    })
  print(sortedArray)
  // ["a", "A", "B", "b", "C", "c"]
  
  alphabet.sort(comparator: { (obj1, obj2) -> ComparisonResult in
      return (obj1 as! String).caseInsensitiveCompare(obj2 as! String)
                            })
  print(alphabet)
  // ["a", "A", "B", "b", "C", "c"]
  ```

  - Sort Descriptor는 요소를 정렬할 때 기준이 되는 대상 또는 속성을 지정하여 NSSortDescriptor 클래스를 통해 사용할 수 있음. 배열에 KVC를 지원하는 요소가 저장되어 있을 때 오름차순 또는 내림차순으로 정렬하는 코드를 쉽게 작성 가능

  ```swift
  var alphabet = NSMutableArray(array: ["A", "B", "C", "D", "E"])
  for i in 0..<(alphabet.count-1) {
      let j = Int(arc4random_uniform(UInt32(alphabet.count-1))) + i
      swap(&alphabet[i], &alphabet[j])
  }
  print(alphabet)
  // ["B", "E", "C", "A", "D"]
  
  let asc = NSSortDescriptor(key: "self", ascending: true)
  var sortedArray = alphabet.sortedArray(using: [asc])
  print(sortedArray)
  // ["A", "B", "C", "D", "E"]
  
  let desc = NSSortDescriptor(key: "self", ascending: false)
  sortedArray = alphabet.sortedArray(using: [desc])
  print(sortedArray)
  // ["E", "D", "C", "B", "A"]
  ```

- Array

  - sort() : 정렬된 새로운 배열을 리턴
  - sorted() : 배열에 포함된 요소를 정렬

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  for i in 0..<(alphabet.count-1) {
      let j = Int(arc4random_uniform(UInt32(alphabet.count-1))) + i
      guard i != j else { continue }
      alphabet.swapAt(i, j)
  }
  print(alphabet)
  // ["B", "E", "D", "C", "A"]
  
  let sortedArray = alphabet.sorted()
  print(sortedArray)
  // ["A", "B", "C", "D", "E"]
  
  alphabet.sort()
  print(alphabet)
  // ["A", "B", "C", "D", "E"]
  ```

  - 클로저 사용 가능

  ```swift
  var alphabet = ["A", "B", "C", "D", "E"]
  for i in 0..<(alphabet.count-1) {
      let j = Int(arc4random_uniform(UInt32(alphabet.count-1))) + i
      guard i != j else { continue }
      alphabet.swapAt(i, j)
  }
  print(alphabet)
  // ["B", "E", "D", "C", "A"]
  
  let sortedArray = alphabet.sorted { $0 > $1 }
  print(sortedArray)
  // ["E", "D", "C", "B", "A"]
  
  alphabet.sort { $0 > $1 }
  print(alphabet)
  // ["E", "D", "C", "B", "A"]
  ```

  - reversed() : 역순 정렬시 사용. 리턴 값은 형식 추론을 통해 ReverseRandomAccessCollection이 되기 때문에 자료형을 직접 지정해 주거나 생성자에 전달하면 별도의 형변환 없이 역순으로 정렬된 배열 획득 가능

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  var result = alphabet.reversed()
  print(alphabet)
  // ReverseRandomAccessCollection<Array<String>>(_base: ["E", "D", "C", "B", "A"])
  
  var result2: [String] = alphabet.reversed()
  print(result2)
  // ["E", "D", "C", "B", "A"]
  
  var result2 = [String](alphabet.reversed())
  print(result2)
  // ["E", "D", "C", "B", "A"]
  ```



#### 3.9 범위 추출

- 특정 범위에 있는 요소들을 새로운 배열로 추출하려는 경우 사용

  - (NSArray) subarray(with: )

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let subArray = alphabet.subarray(with:NSMakeRange(1, 3))
  print(subArray)
  // ["B", "C", "D"]
  ```

  - (Array) 서브스크립트 문법과 범위 연산자를 조합하여 배열 추출

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let subArray = alphabet[1..<4]
  print(subArray)
  // ["B", "C", "D"]
  ```

- dropFirst() : 배열의 첫번째 요소를 제외한 나머지 요소를 새로운 배열로 리턴

- dropFirst(_: ) : 전달된 정수 파라미터 n개의 요소를 앞에서부터 제외한 나머지 요소의 배열이 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  let result = alphabet.dropFirst()
  print(result)
  // ["B", "C", "D", "E"]
  
  result = alphabet.dropFirst(3)
  print(result)
  // ["D", "E"]
  ```

- dropLast() : 배열의 마지막 요소를 제외한 나머지 요소를 새로운 배열로 리턴

- dropLast(_: ) : 전달된 정수 파라미터 n개의 요소를 뒤에서부터 제외한 나머지 요소의 배열이 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  let result = alphabet.dropLast()
  print(result)
  // ["A", "B", "C", "D"]
  
  result = alphabet.dropLast(3)
  print(result)
  // ["A", "B"]
  ```

- prefix(_: ) : 전달된 정수 파라미터 n개의 요소를 앞에서부터 추출하여 새로운 배열을 리턴

- prefix(upTo: ) : 첫번째 요소부터 전달된 정수 파라미터인 지정된 인덱스 이전까지의 요소를 추출하여 새로운 배열을 리턴

- prefix(through: ) : prefix(upTo: )와 비슷하지만 전달된 파라미터인 지정된 인덱스 까지의 요소를 추출

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  let result = alphabet.prefix(2)
  print(result)
  // ["A", "B"]
  
  result = alphabet.prefix(upTo: 2)
  print(result)
  // ["A", "B"]
  
  result = alphabet.prefix(through: 2)
  print(result)
  // ["A", "B", "C"]
  ```

- suffix(_: ) : 전달된 정수 파라미터 n개의 요소를 뒤에서부터 추출하여 새로운 배열을 리턴

- suffix(from: ) : 전달된 정수 파라미터인 지정된 인덱스부터 마지막 요소까지 추출하여 새로운 배열을 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  
  let result = alphabet.suffix(2)
  print(result)
  // ["D", "E"]
  
  result = alphabet.suffix(from: 2)
  print(result)
  // ["C", "D", "E"]
  ```



#### 3.10 배열 변환

- 병합 - 배열에 저장된 요소들을 파라미터로 전달한 분리자로 연결한 문자열을 리턴

  - (NSArray) componentJoined(by: ) 
  - (Array) joined(separator: )

  ```swift
  let alphabet: NSArray = ["A", "B", "C", "D", "E"]
  let str = alphabet.componentJoined(by: "#")
  
  print(str)
  // A#B#C#D#E
  ```

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let str = alphabet.joined(separator: "#")
  
  print(str)
  // A#B#C#D#E
  ```

- map(_: ) : Array배열의 모든 요소를 순회하면서 파라미터로 전달한 클로저를 실행한 결과값을 포함하고 있는 새로운 배열을 리턴

  ```swift
  let alphabet = ["A", "B", "C", "D", "E"]
  let result = alphabet.map { $0.lowercased() }
  
  print(result)
  // ["a", "b", "c", "d", "e"]
  ```



#### 3.11 Array 배열의 메모리 공간과 최적화

- 배열은 초기화에 사용된 요소의 수에 따라 최초 저장 공간의 크기가 결정

- 요소를 추가할 공간이 부족할 경우, 새로운 저장 공간을 할당할 때, 이전의 2배 크기의 공간을 할당 (Exponential Growth Strategy)

- 필요한 저장 공간의 크기를 미리 예측 가능하다면, reserveCapacity(_: ) 메소드를 통해 원하는 저장 공간 할당 가능. 해당 메소드로 할당되는 공간의 크기는 파라미터로 전달한 크기보다 크거나 같음.

  ```swift
  var list = ["A", "B", "C"]
  print("total: \(list.capacity), current: \(list.count)")
  // total: 3, current: 3
  
  list += ["D"]
  print("total: \(list.capacity), current: \(list.count)")
  // total: 6, current: 4
  
  list += ["E", "F", "G", "H", "I"]
  print("total: \(list.capacity), current: \(list.count)")
  // total: 12, current: 9
  
  list[1..<6] = ["A"]
  print("total: \(list.capacity), current: \(list.count)")
  // total: 12, current: 5
  
  var reservedList = [String]()
  reservedList.reserveCapacity(100)
  print("total: \(reservedList.capacity), current: \(reservedList.count)")
  // total: 105, current: 0
  ```



### 4. 딕셔너리

- Key-value쌍으로 순서없이 저장하는 컬렉션

  ```swift
  [키1:값1, 키2:값2, 키3:값3, ..., 키N:값N]
  [:] // 빈 딕셔너리
  ```

  ```swift
  // 딕셔너리의 자료형 표현 방식
  Dictionary<키의 자료형, 값의 자료형> 
  [키의 자료형: 값의 자료형] // 단축 문법
  ```

- Swift에서 빈 딕셔너리로 초기화하는 경우에는 반드시 키와 값의 자료형을 지정해야 함

  ```swift
  // Swift Dictionary
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
   
  // Foundation Dictionary
  let nsWords: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  ```

  ```swift
  // 빈 배열 선언
  // Foundation Dictionary
  let emptyNSDict = NSMutableDictionary()
  
  // Swift Dictionary
  var emptyWordDict1: Dictionary<String, String> = [:]
  var emptyWordDict2: [String: String] = [:]
  var emptyWordDict3 = [String: String]()
  ```



#### 4.1 배열에 포함된 요소의 수

- 요소의 수는 count속성으로 확인 가능

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  let countOfWords = words.count
  
  if countOfWords > 0 {
      print("\(countOfWords) element(s)")
  } else {
      print("empty dictionary")
  }
  // 3 element(s)
  ```

- 딕셔너리가 비어 있는지 확인하기 위해 isEmpty속성 사용 가능

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  let countOfWords = words.count
  
  if !words.isEmpty {
      print("\(countOfWords) element(s)")
  } else {
      print("empty dictionary")
  }
  // 3 element(s)
  ```



#### 4.2 요소에 접근

- 요소에 접근할 때 키를 전달하면 키와 연관된 값을 읽거나 변경 가능

- NSDictionary - object(forKey: ) 메소드를 제공

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  let aValue = words.object(forKey:"A")
  
  print(aValue)
  // Optional(Apple)
  
  let zValue = words.object(forKey:"Z")
  print(zValue)
  // nil
  ```

  - 배열의 경우 존재하지 않는(범위 밖) 인덱스를 전달할 경우 런타임 오류가 발생하지만 딕셔너리는 존재하니 않는 키를 전달해도 런타임 오류가 발생하지 않음

- Swift는 주로 옵셔널 바인딩 구문과 결합해서 사용

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  
  if let aValue = words.object(forKey:"A") {
      // ...
  } 
  ```

- 배열과 마찬가지로 요소 접근시 서브스크립트 문법 사용 가능. 배열의 문법과 동일하지만 인덱스 대신 키를 전달

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  
  if let aValue = words["A"]) {
      print(aValue)
  } else {
      print("Not found")
  }
  // Apple
  
  if let zValue = words["Z"]) {
      print(zValue)
  } else {
      print("Not found")
  }
  // Not found
  ```

- Swift 4부터는 서브스크립트로 기본값 전달 가능

  ```swift
  [키, default:기본값]
  ```

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  
  words["A"]
  // Apple
  
  words["Z"]
  // nil
  
  words["z", default: "No Words"]
  // No Words
  ```



#### 4.3 키, 값 검색

- NSDictionary

  - object(forKey: ) : 리턴값을 통해 지정된 키가 존재하는지 확인
  - allKeys.contains(_: ) : allKeys속성으로 키 배열을 얻은 후, 해당 키가 포함되었는지 확인 가능

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  let key = "K"
  
  if let _ = words.object(forKey: key) {
      print("The key \"\(key)\" exists.")
  } else {
      print("The key \"\(key)\" not exists.")
  }
  
  if words.allKeys.contains(where: { $0 as! String == key}) {
      print("The key \"\(key)\" exists.")
  } else {
      print("The key \"\(key)\" not exists.")
  }
  // The key "K" not exists.
  ```

  - allKeys(for: ) : 해당 값을 포함하는 모든 키 배열을 획득. count속성으로 키의 존재 여부 확인 가능

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  let keys = words.allKeys(for: "Apple")
  
  print("Key count of Apple: \(keys.count)")
  //Key count of Apple: 1
  ```

  - 클로저를 이용한 상세 조건 검색

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  
  let result = words.keysOfEntries(passingTest: { (key, obj, stop) -> Bool in
      if let value = obj as? Sting {
          return value.range(of:"a", options: .caseInsensitive) != nil;
      }
  		return false
  })
  
  for keyObj in result {
      if let key = keyObj as? NSString, let value = words[key] {
          print("\(key) - \(value)")
      }
  }
  
  // A - Apple
  // B - Banana
  ```

  - 클로저로 조건을 만족시 중단하려면 stop파라미터를 이용

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  
  let result = words.keysOfEntries(options: [], passingTest: { (key, obj, stop) -> Bool in
      if let value = obj as? Sting {
          stop.pointee = true
          return value.range(of:"a", options: .caseInsensitive) != nil;
      }
  		return false
  })
  
  for keyObj in result {
      if let key = keyObj as? NSString, let value = words[key] {
          print("\(key) - \(value)")
      }
  }
  
  // A - Apple
  ```

- Dictionary

  - Contains(where: ) : 검색 조건을 구현하는 클로저를 파라미터로 지정

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  
  if words.contains(where: { (key, value) -> Bool in return key == "A"}) {
      print("contains A key.")
  }
  
  if words.contains(where: { $0.1 == "City"}) {
      print("contains City value.")
  }
  
  // contains A key.
  // contains City value.
  ```

  - Filter(_: ) : 지정된 조건으로 딕셔너리를 검색후, 조건과 일치하는 요소를 튜플 배열로 리턴

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  
  let result = words.filter { (key, value) -> Bool in
      return value.lowercased().contains("a")
  }
  
  for (key, value) in result {
      print("\(key) - \(value)")
  }
  
  // B - Banana
  // A - Apple
  ```



#### 4.4 딕셔너리 비교

- 저장된 요소의 수가 동일하고 키와 값이 모두 일치하면 동일한 딕셔너리로 판단. 딕셔너리는 정렬되지 않은 컬렉션이므로 요소가 저장된 순서는 비교 조건에서 제외됨

- NSDictionary

  - isEqual(to: ) : 두 딕셔너리를 비교

  ```swift
  let words: NSDictionary = ["A": "Apple", "B": "Banana", "C": "City"]
  let anotherWords = ["B": "Banana", "C": "City", "A": "Apple"]
  let countryCodes = ["KR": "South Korea", "US": "United States"]
  
  if words.isEqual(to: anotherWords) {
      print("words == anotherWords")
  } else {
      print("words != anotherWords")
  }
  // words == anotherWords
  
  if words.isEqual(to: countryCodes) {
      print("words == countryCodes")
  } else {
      print("words != countryCodes")
  }
  // words != countryCodes
  ```

- Dictionary

  - Swift의 ==연산자와 !=연산자는 Dictionary를 비교할 수 있도록 재정의되어 있음. ==연산자는 NSDictionary의 isEqual(to: )메소드와 동일한 결과를 얻을 수 있음

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  let anotherWords = ["B": "Banana", "C": "City", "A": "Apple"]
  let countryCodes = ["KR": "South Korea", "US": "United States"]
  
  if words == anotherWords {
      print("words == anotherWords")
  } else {
      print("words != anotherWords")
  }
  // words == anotherWords
  
  if words == countryCodes {
      print("words == countryCodes")
  } else {
      print("words != countryCodes")
  }
  // words != countryCodes
  ```

  - ==연산자는 딕셔너리에 저장된 개별 요소를 ==연산자로 비교. 문자열을 비교할 때 대소문자 구분

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  let upperWords = ["A": "APPLE", "B": "BANANA", "C": "CITY"]
  
  if words == upperWords {
      print("words == upperWords")
  } else {
      print("words != upperWords")
  }
  // words != upperWords
  ```

  - elementsEqual(_: by: )는 비교 조건을 상세하게 구현해야 할 때 유용함. 두번째 파라미터는 각 요소를 비교하여 결과를 Bool로 리턴하는 클로저

  ```swift
  let words = ["A": "Apple", "B": "Banana", "C": "City"]
  let upperWords = ["A": "APPLE", "B": "BANANA", "C": "CITY"]
  
  let equals = words.elementsEqual(upperWords) { (lhs, rhs) -> Bool in
      return lhs.0.lowercased() == rhs.0.lowercased() &&
             lhs.1.lowercased() == rhs.1.lowercased()
  }
  
  print(equals)
  // true
  ```



#### 4.5 새로운 요소 추가와 교체

- NSMutableDictionary

  - setObject(_: forKey: ) : 파라미터로 전달한 키가 딕셔너리에 존재하지 않을 경우 새로운 요소를 추가하고, 이미 존재하는 경우 키와 연관된 값을 첫번째 파라미터의 값으로 교체함

  ```swift
  let words = NSMutableDictionary()
  words.setObject("Apple", forKey: "A" as NSCopying)
  words.setObject("Banana", forKey: "B" as NSCopying)
  
  print(words)
  // ["B": "Banana", "A": "Apple"]
  
  words.setObject("Blue", forKey: "B" as NSCopying)
  
  print(words)
  // ["B": "Blue", "A": "Apple"]
  ```

  ```swift
  let words = NSMutableDictionary()
  words["A"] = "Apple"
  words["B"] = "Banana"
  print(words)
  // ["B": "Banana", "A": "Apple"]
  
  words["B"] = "Blue"
  print(words)
  // ["B": "Blue", "A": "Apple"]
  ```

- Dictionary

  - NSDictionary와 동일하게 서브스크립트 문법을 사용하여 요소의 추가/교체가 가능함

  ```swift
  var words = [String: String]()
  words["A"] = "Apple"
  words["B"] = "Banana"
  print(words)
  // ["B": "Banana", "A": "Apple"]
  
  words["B"] = "Blue"
  print(words)
  // ["B": "Blue", "A": "Apple"]
  ```

  - updateValue(_: forKey: ) : NSDictionary의 setObject( _: forKey:  )와 동일한 기능을 제공하지만, 파라미터로 전달한 키가 이미 존재하는 경우 교체되기 전 값을 리턴. 키가 존재하지 않을 경우에는 nil을 리턴

  ```swift
  var words = [String: String]()
  if let oldValue = words.updateValue("Apple", forKey: "A") {
      print("\(oldValue) => \(words["A"]!)")
  } else {
      print("+ \(words["A"]!)")
  }
  // + Apple
  
  if let oldValue = words.updateValue("Apricot", forKey: "A") {
      print("\(oldValue) => \(words["A"]!)")
  } else {
      print("+ \(words["A"]!)")
  }
  // Apple => Apricot
  ```



#### 4.6 요소 삭제

- 서브스크립트를 이용하여 키와 연관된 값을 nil로 변경. 키가 딕셔너리에 존재하면 요소를 삭제하고, 존재하지 않으면 무시

  ```swift
  // Swift Dictionary
  var words = ["A": "Apple", "B": "Banana", "C": "City"]
  words["C"] = nil
  print(words)
  // ["A": "Apple", "B": "Banana"]
  
  // Foundation Dictionary
  let nsWords = NSMutableDictionary(dictionary: ["A": "Apple", "B": "Banana", "C": "City"])
  nsWords["C"] = nil
  print(nsWords)
  // ["A": "Apple", "B": "Banana"]
  ```

- NSMutableDictionary

  - removeObject(forKey: ) : 하나의 요소를 삭제
  - removeObjects(forKeys: ) : 두 개 이상의 요소를 동시에 삭제
  - removeAllObjects : 모든 요소를 삭제

  ```swift
  let words = NSMutableDictionary(dictionary: ["A": "Apple", "B": "Banana", "C": "City", "D": "Drama", "E": "Earth", "F": "Fuel"])
  
  words.removeObject(forKey: "D")
  print(words)
  // ["B": "Banana", "A": "Apple", "F": "Fuel", "C": "City", "E": "Earth"]
  
  words.removeObjects(forKeys: ["A", "F"])
  print(words)
  // ["C": "City", "B": "Banana", "E": "Earth"]
  
  words.removeAllObjects()
  print(words)
  // [: ]
  ```

- Dictionary

  - removeValue(forKey: ) : 하나의 요소를 삭제. 정상적으로 삭제된 경우 삭제된 요소의 값을 리턴
  - removeAll() : 모든 요소와 메모리 공간을 삭제

  ```swift
  var words = ["A": "Apple", "B": "Banana", "C": "City", "D": "Drama", "E": "Earth", "F": "Fuel"]
  
  if let removedValue = words.removeValue(forKey: "D") {
      print("\(removedValue) removed!")
  }
  // Drama removed!
  
  print(words)
  // ["B": "Banana", "A": "Apple", "F": "Fuel", "C": "City", "E": "Earth"]
  
  words.removeAll()
  print(words)
  // [: ]
  ```

  - 딕셔너리의 모든 요소를 삭제한 후, 재사용을 위해 메모리 공간을 삭제하지 않도록 지정 가능

  ```swift
  words.removeAll(keepingCapacity: true)
  ```



### 5. 셋

- 수학의 집합 개념을 구현한 컬렉션

- 저장되는 요소는 정렬되지 않으며 동일한 요소는 한 번만 저장됨

- 정렬 순서보다 검색 속도가 중요할 때, 배열보다 나은 성능을 제공

  ```swift
  [요소1, 요소2, 요소3, ..., 요소N]
  [] // 빈 셋
  ```

- 셋 리터럴은 배열 리터럴과 동일하기 떄문에 형식 추론에서는 항상 배열로 추론되므로 셋 리터럴을 사용하려면 명시적으로 자료형을 지정해야 됨

- 이미 존재하는 배열이나 다른 셋을 기반으로 새로운 NSSet의 생성 가능

  ```swift
  let fruitsArray = ["Apple", "Orange", "Melon"]
  
  let fruitsFromArray = NSSet(array: fruitsArray)
  let fruitsFromSet = NSSet(set: fruitsFromArray)
  let fruits = NSSet(objects: "Apple", "Orange", "Melon")
  let emptySet = NSSet()
  ```

- Swift에서 리터럴을 통해 셋을 초기화하는 경우에는 반드시 자료형을 지정해야 함. 지정하지 않으면 배열로 인식

- 선언과 동시에 초기화하는 경우 형식추론을 통해 셋에 저장할 요소의 자료형을 생략할 수 있지만 Type Annotation자체를 생략할 수는 없음

  ```swift
  let fruits: Set<String> = ["Apple", "Orange", "Melon"]
  let numbers: Set = [1, 2, 3]
  let emptySet = Set<String>()
  ```



#### 5.1 요소의 수

- count속성으로 요소의 수 확인

- 빈 배열 체크 : [NSSet] anyObject() , [Set] isEmpty를 통해 체크 가능

  ```swift
  // 	Swift Set
  let fruits: Set<String> = ["Apple", "Orange", "Melon"]
  var countOfFruits = fruits.count
  
  if !fruits.isEmpty {
      print("\(countOfFruits) element(s)")
  } else {
      print("empty set")
  }
  // 3 element(s)
  
  // 	Foundation Set
  let nsFruits = NSSet(set: fruits)
  countOfFruits = nsFruits.count
  
  if let _ = nsFruits.anyObject() {
      print("\(countOfFruits) element(s)")
  } else {
      print("empty set")
  }
  // 3 element(s)
  ```



#### 5.2 요소 검색

- contain(_: ) : 파라미터로 전달한 객체가 셋에 존재하는지 확인함

  ```swift
  let fruits: NSSet = ["Apple", "Orange", "Melon"]
  
  if fruits.contains("Apple") {
      // ...
  }
  ```

  ```swift
  let fruits = ["Apple", "Orange", "Melon"]
  
  if fruits.contains("Apple") {
      // ...
  }
  ```

  - NSSet은 NSPredicate를 활용하여 상세한 검색 조건을 지정할 수 있음. 

    - filtered(using: ) : NSPredicate를 통해 지정한 조건과 일치하는 요소를 새로운 셋으로 리턴

    ```swift
    let productSet = NSSet(objects: "iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro")
    
    let prifixPredicate = NSPredicate(format: "SELF BEGINSWITH %@", "i")
    let filteredSet = productSet.Filtered(using: prefixPredicate)
    
    print(filteredSet)
    // {"iPhone", "iPad", "iPad Pro"}
    
    let mutableProductSet = NSMutableSet(set: preductSet)
    
    let suffixPredicate = PSPredicate(format: "SELF ENDSWITH %@", "o")
    mutableProductSet.filter(using: suffixPredicate)
    
    print(mutableProductSet)
    // {"Mac Pro", "iPad Pro", "Macbook Pro"}
    ```

  - Set에서 상세한 검색 조건을 구현하려면 filter(_: ) 메소드를 사용. 검색 조건이 구현된 클로저를 파라미터로 받으며 검색 결과를 새로운 셋으로 리턴

    ```swift
    let productSet: Set = ["iPhone", "iPad", "Mac Pro", "iPad Pro", "Macbook Pro"]
    let filteredSet = productSet.filter { $0.hasPrefix("i")}
    print(filterSet)
    // {"iPhone", "iPad", "iPad Pro"}
    ```

    

#### 5.3 요소 추가

  - add(_: ) : 새로운 요소를  NSMutableSet에 추가. 

  - addObjects(from: ) : 배열에 저장되어 있는 모든 요소를 추가.

  - 추가할 요소가 이미 존재하는 경우 추가되지 않음

    ```swift
    let set = NSMutableSet()
    set.add("Apple")
    set.add("Apple")
    
    print(set)
    // {"Apple"}
    
    var alphabet = ["A", "B"]
    set.addObjects(from: alphabet)
    
    print(set)
    // {"Apple", "A", "B"}
    
    alphabet = ["A", "B", "C"]
    set.addObjects(from: alphabet)
    
    print(set)
    // {"Apple", "A", "B", "C"}
    ```

  - insert(_: ) : Set에 새로운 요소를 추가. Swift 3.0부터 튜플을 통해 메소드 실행 결과를 리턴. 셋에 새로운 요소를 추가한 경우 (true, 새로운 요소 값)튜플이 리턴되고, 이미 동일한 요소가 존재하는 경우에는 (false, 이미 존재하는 요소 값) 튜플이 리턴됨

    ```swift
    var set: Set<String> = []
    set.insert("Apple")
    print(set)
    // {"Apple"}
    
    var result = set.insert("Orange")
    print(result)
    // {true, "Orange"}
    
    print(set)
    // {"Apple", "Orange"}
    
    result = set.insert("Orange")
    print(result)
    // {false, "Orange"}
    
    print(set)
    // {"Apple", "Orange"}
    ```

    

#### 5.4 요소 삭제

  - remove(_: ) : NSMutableSet에 저장된 하나의 요소를 삭제

  - removeAllObjects() : 모든 요소를 삭제

    ```swift
    let set = NSMutableSet(array: ["Apple", "Orange", "Melon"])
    set.remove("Apple")
    
    print(set)
    // {"Orange", "Melon"}
    
    set.removeAllObjects()
    print(set)
    // {}
    ```

  - remove(_: ) : Set에 저장된 요소를 삭제하고 삭제한 요소를 리턴. 파라미터로 전달된 요소가 존재하지 않는 경우 nil리턴

  - removeAll() : 모든 요소를 삭제

  - 배열과 마찬가지로 keepingCapacity파라미터를 사용해서 메모리 사용을 최적화할 수 있음

    ```swift
    var set: Set = ["Apple", "Orange", "Melon"]
    
    if let removed = set.remove("Apple") {
        print("\(removed) has been removed!")
    }
    // Apple has been removed!
    
    print(set)
    // {"Orange", "Melon"}
    
    set.removeAll(keepingCapacity: true)
    
    print(set)
    // {}
    ```



#### 5.5 비교, 부분집합

  - NSSet

    - NSSet을 비교하는 메소드는 isEqual(to: )

    ```swift
    let favoriteFruits = NSSet(objects: "Apple", "Orange", "Melon")
    let tropicalFruits = NSSet(objects: "Banana", "Papaya", "Kiwi", "Pineapple")
    
    if favoriteFruits.isEqual(to: tropicalFruits as Set<NSObject>) {
      	print("favoriteFruits == tropicalFruits")
    } else {
      	print("favoriteFruits != tropicalFruits")
    }
    // favoriteFruits != tropicalFruits
    
    ```

    - isSubset(of: ) : NSSet이 파라미터로 전달된 집합의 부분집합일 때 true를 리턴

    ```swift
    let tropicalFruits = NSSet(objects: "Banana", "Papaya", "Kiwi", "Pineapple")
    let yellowFruits = NSSet(array: ["Banana"])
    
    if yellowFruits.isSubset(of: tropicalFruits) {
      	print("yellowFruits ⊂ tropicalFruits")
    } else {
      	print("yellowFruits ⊄ tropicalFruits")
    }
    // yellowFruits ⊂ tropicalFruits
    ```

- Set

  - Set은 비교연산자를 통해 비교하거나 elementsEqual(_: ) 메소드로 비교가능

  ```swift
  let favoriteFruits = NSSet(objects: "Apple", "Orange", "Melon")
  let tropicalFruits = NSSet(objects: "Banana", "Papaya", "Kiwi", "Pineapple")
  
  if favoriteFruits == tropicalFruits {
    	print("favoriteFruits == tropicalFruits")
  } else {
    	print("favoriteFruits != tropicalFruits")
  }
  
  if favoriteFruits.elementsEqual(tropicalFruits) {
    	print("favoriteFruits == tropicalFruits")
  } else {
    	print("favoriteFruits != tropicalFruits")
  }
  // favoriteFruits != tropicalFruits
  ```

  - isSubset(of: ) : NSSet이 파라미터로 전달된 집합의 부분집합일 때 true를 리턴
  - isStrictSubset(of: ) : 집합 A가 집합 B의 진부분집합인지 확인하는 메소드
  - isSuperset(of: ) : 집합 B가 집합 A의 상위집합인지 확인하는 메소드
  - isStrictSuperset(of: ) : 진상위집합인지 확인하는 메소드

  ```swift
  let tropicalFruits = NSSet(objects: "Banana", "Papaya", "Kiwi", "Pineapple")
  let yellowFruits = NSSet(array: ["Banana"])
  
  if yellowFruits.isSubset(of: tropicalFruits) {
    	print("yellowFruits ⊂ tropicalFruits")
  } else {
    	print("yellowFruits ⊄ tropicalFruits")
  }
  // yellowFruits ⊂ tropicalFruits
  
  if yellowFruits.isStrictSubset(of: tropicalFruits) {
    	print("yellowFruits ⊂ tropicalFruits")
  } else {
    	print("yellowFruits ⊄ tropicalFruits")
  }
  // yellowFruits ⊂ tropicalFruits
  
  if tropicalFruits.isSuperset(of: yellowFruits) {
    	print("tropicalFruits ⊃ yellowFruits")
  } else {
    	print("tropicalFruits ⊅ yellowFruits")
  }
  // tropicalFruits ⊃ tropicalFruits
  
  if tropicalFruits.isStrictSuperset(of: yellowFruits) {
    	print("tropicalFruits ⊃ yellowFruits")
  } else {
    	print("tropicalFruits ⊅ yellowFruits")
  }
  // tropicalFruits ⊃ yellowFruits
  ```

  

#### 5.6 집합 연산 - 교집합

- (NSSet) intersects(_: ) : 두 집합에 공통적인 요소가 포함되어 있는지 확인

- (NSMutableSet) intersect(_: ) : 현재 집합에서 파라미터로 전달한 집합과의 교집합을 제외한 나머지 요소를 삭제함

  ```swift
  let favoriteFruits = NSSet(objects: "Apple", "Orange", "Melon")
  let tropicalFruits = NSSet(objects: "Banana", "Papaya", "Kiwi", "Pineapple")
  
  if favoriteFruits.intersects(tropicalFruits as Set<NSObject>) {
    	print("favoriteFruits ∩ tropicalFruits")
    
    	tropicalFruits.intersect(favoriteFruits as Set<NSObject>)
    	print(tropicalFruits)
  } else {
    	print("favoriteFruits ∩ tropicalFruits = ∅")
  }
  // favoriteFruits ∩ tropicalFruits
  // {"Kiwi"}
  ```

- (Set) isDisjoint(with: ) : 두 집합이 서로소인지 확인

- (Set) intersection(_: ) : 두 집합의 교집합을 새로운 셋으로 리턴

- (Set) formIntersection(_: ) : 현재 집합에서 파라미터로 전달한 집합과의 교집합을 제외한 나머지 요소를 삭제함

  ```swift
  let favoriteFruits = NSSet(objects: "Apple", "Orange", "Melon")
  var tropicalFruits = NSSet(objects: "Banana", "Papaya", "Kiwi", "Pineapple")
  
  if favoriteFruits.isDisjoint(with: tropicalFruits) {
    	print("favoriteFruits ∩ tropicalFruits = ∅")
  } else {
    	print("favoriteFruits ∩ tropicalFruits")
  }
  // "favoriteFruits ∩ tropicalFruits"
  
  let commonSet = favoriteFruits.intersection(tropicalFruits)
  
  print(commonSet)
  // {"Kiwi"}
  
  tropicalFruits.formIntersection(favoriteFruits)
  
  print(tropicalFruits)
  // {"Kiwi"}
  ```



#### 5.7 집합 연산 - 합집합

- (NSMutableSet) union(_: ) : 파라미터로 전달된 집합의 요소 중 NSMutableSet에 존재하지 않는 요소를 추가

  ```swift
  let favoriteFruits = Set(["Apple", "Orange", "Melon"])
  var tropicalFruits = Set(["Banana", "Papaya", "Kiwi", "Pineapple"])
  
  let unionSet = NSMutableSet(set: favoriteFruits)
  unionSet.union(tropicalFruits)
  
  print(unionSet)
  // {"Orange", "Banana", "Papaya", "Pineapple", "Kiwi", "Apple", "Melon"}
  ```

- (Set) union(_: ) : 두 집합의 합집합을 새로운 셋으로 리턴

- (Set) formUnion(_: ) : 현재 집합에 파라미터로 전달한 집합의 요소를 추가

  ```swift
  let favoriteFruits = Set(["Apple", "Orange", "Melon"])
  let tropicalFruits = Set(["Banana", "Papaya", "Kiwi", "Pineapple"])
  
  var unionSet = favoriteFruits.union(tropicalFruits)
  print(unionSet)
  // {"Orange", "Banana", "Papaya", "Pineapple", "Kiwi", "Apple", "Melon"}
  
  unionSet = Set(favoriteFruits)
  unionSet.formUnion(tropicalFruits)
  
  print(unionSet)
  // {"Orange", "Banana", "Papaya", "Pineapple", "Kiwi", "Apple", "Melon"}
  ```



#### 5.8 집합 연산 - 차집합

- (NSMutableSet) minus(_: ) : 파라미터로 전달된 집합에 있는 모든 요소를 현재 집합에서 제거

  ```swift
  let favoriteFruits = NSMutableSet(array: ["Apple", "Orange", "Melon", "Kiwi"])
  let tropicalFruits = Set(["Banana", "Papaya", "Kiwi", "Pineapple"])
  
  favoriteFruits.minus(tropicalFruits)
  
  print(favoriteFruits)
  // {"Apple", "Orange", "Melon"}
  ```

- (Set) subtracting(_: ) : 두 집합의 차집합을 새로운 셋으로 리턴

- (Set) subract(_: ) : 현재 집합에서 파라미터로 전달한 집합과의 교집합을 제거

  ```swift
  var favoriteFruits = Set(["Apple", "Orange", "Melon", "Kiwi"])
  let tropicalFruits = Set(["Banana", "Papaya", "Kiwi", "Pineapple"])
  
  let uncommonSet = favoriteFruits.subtracting(tropicalFruits)
  
  print(uncommonSet)
  // {"Apple", "Orange", "Melon"}
  
  favoriteFruits.subtract(tropicalFruits)
  
  print(favoriteFruits)
  // {"Apple", "Orange", "Melon"}
  ```



#### 5.9 집합 연산 - 여집합

- (Set) symmetricDifference(_: ) : 두 집합에 공통적으로 존재하는 요소를 제외한 나머지 요소들을 새로운 셋으로 리턴

- (Set) formSymmetricDifference(_: ) : 새로운 셋을 리턴하지 않고 현재 셋의 내용을 변경함

  ```swift
  var favoriteFruits = Set(["Apple", "Orange", "Melon", "Kiwi"])
  let tropicalFruits = Set(["Banana", "Papaya", "Kiwi", "Pineapple"])
  
  let exclusiveSet = favoriteFruits.symmetricDifference(tropicalFruits)
  print(exclusiveSet)
  // {"Apple", "Orange", "Melon", "Banana", "Pineapple", "Papaya"}
  
  favoriteFruits.formSymmetricDifference(tropicalFruits)
  print(favoriteFruits)
  // {"Apple", "Orange", "Melon", "Banana", "Pineapple", "Papaya"}
  ```



#### 5.10 NSCountedSet

- 중복을 허용하는 특수한 셋

- 동일한 요소를 추가할 경우, 별도로 요소를 추가하지 않고 해당 요소가 저장된 횟수를 함께 저장함. 메모리 공간의 효율적 사용

- 동일한 요소를 셋에서 완전히 제거하려면 추가된 횟수만큼 반복적으로 삭제해야 함

  ```swift
  let set = NSCountedSet()
  set.add("Apple")
  set.add("Apple")
  set.add("Apple")
  
  print(set)
  // {"Apple"}
  
  var countOfApple = set.count(for: "Apple")
  
  print(countOfApple)
  // 3
  
  set.remove("Apple")
  
  print(set)
  // {"Apple"}
  
  var countOfApple = set.count(for: "Apple")
  
  print(countOfApple)
  // 2
  
  set.remove("Apple")
  set.remove("Apple")
  
  print(set)
  // {}
  
  var countOfApple = set.count(for: "Apple")
  
  print(countOfApple)
  // 0
  ```

  

### 6. Fast Enumeration

- 컬렉션에 저장된 모든 데이터를 순회하면서 필요한 작업을 수행하는 것을 열거라 함. 반복문을 통해서 컬렉션을 열거할 수도 있지만, 열거의 범위를 벗어나거나 일부 요소를 누락시키는 실수가 발생하기 때문에 Fast Enumeration(빠른 열거)을 사용
- 단순한 문법으로 높은 성능의 코드 구현
- 멀티쓰레드 환경에서 다수의 열거를 동시에 수행 가능
- 열거 수행하는 동안에는 컬렉션의 요소 수정 불가능
- Fast Enumeration은 for-in 반복문 또는 클로저 기반의 메소드로 구현. 클로저를 사용할 경우 각 순회 단계마다 인덱스와 요소가 함께 전달됨

#### 6.1 배열, 셋 열거

- 열거

  ```swift
  for 요소 상수 in 배열 또는 셋 {
    	반복할 코드
  }
  ```

- 배열과 셋의 열거 방법은 동일. 그러나 배열은 항상 오름차순으로 전달되지만 셋은 전달되는 순서가 달라질 수 있음

  ```swift
  
  ```

  


