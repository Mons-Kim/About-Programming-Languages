# 속성

- 형식의 특징을 결정

  

### 1. 속성과 . 문법

- 점 문법으로 속성에 저장된 값을 읽거나 새로운 값을 할당할 수 있음

  ```swift
  let p = Person()
  let name = p.name
  ```



### 2. Stored Property

- 저장 속성은 가장 일반적인 형태의 속성으로 클래스와 구조체에 추가 가능. 저장 속성을 선언하는 방식은 변수나 상수를 선언하는 방식과 동일

  ```swift
  var 또는 let 속성이름: 속성자료형
  var 또는 let 속성이름: 속성자료형 = 기본값
  ```

  ```swift
  class Person {
  		var name: String = ""
    	var age: Int = 0
  }
  ```

- 반드시 속성의 기본값을 지정하거나 생성자를 구현하여 모든 속성을 초기화해야 함

- 선언과 동시에 기본값을 지정하면 형식추론을 통해 자료형의 생략이 가능함

  ```swift
  class Person {
    	var name = ""
    	var age = 0
  }
  ```

- 구조체의 저장 속성 선언 방식은 클래스와 동일함

  ```swift
  struct Contact {
    	var email: String?
    	var mobile: String?
    	var fax: String?
  }
  ```

- 구조체의 저장 속성은 구조체의 가변서에 영향 받음

  ```swift
  var james = Contact()
  james.email = "james@example.com"
  ```

  ```swift
  let james = Contact()
  james.email = "james@example.com" // Error
  ```

  

### 3. Lazy Stored Property

- 모든 저장 속성은 인스턴스의 초기화가 완료된 시점에 적절한 값으로 초기화되어야 함

- 큰메모리 공간을 필요로 하거나, 한번도 사용하지 않는 경우 불필요한 메모리 낭비가 됨

- 지연 저장 속성은 초기화 과정에서 초기화되지 않고 속성에 처음 접근하는 시점에 초기화가 발생

- lazy 키워드로 지연저장속성을 선언할 수 있음

  ```swift
  lazy var 속성이름: 속성 자료형 = 초기화 표현식
  ```

- lazy로 선언된 지연저장 속성은 반드시 선언부분에서 기본값을 지정해야 함

- 기본값은 리터럴을 사용할 수 있지만, 일반적으로 생성자를 호출하는 표현식을 사용.

- 초기화 표현식을 통해 형식 추론이 가능하므로 속성 자료형 생략 가능

- lazy로 선언한 Contact

  ```swift
  struct Contact {
    	var email: String?
    	var mobile: String?
    	var fax: String?
    
    	init() {
        	print("new Contact instance")
      }
  }
  
  class Person {
    	var name = ""
    	var age = 0
    	
    	lazy var contacts = Contact()
    
    	init() {
        	print("new Person instance")
      }
  }
  
  let james = Person()
  // new Person instance
  
  print(james.name)
  print(james.age)
  
  james.contacts.email = "james@example.com"
  // new Contact instance
  ```

  - 새로운 Person 인스턴스를 생성하고 name, age속성에 접근할 때까지 "new Contact instance"라는 로그 메세지가 출력되지 않음
  - contacts속성에 접근하여 값을 변경하는 시점에 "new Contact instance"로그가 출력됨

- 큰값을 저장하거나 속성의 값이 초기화 이후에 결정되는 값에 의존적인 경우 활용 가능

- 단, 여러 스레드에서 동시에 접근하는 경우 속성이 두 번 이상 초기화 될 가능성이 있으니 주의 



### 4. Computed Property

- 계산 속성은 저장속성과 달리 값을 직접 저장하지 않음

- 저장 속성의 값을 기반으로 계산된 새로운 값을 리턴하거나 전달된 값을 토대로 다른 속성의 값을 갱신함

- 계산 속성은 get블록과 set블록으로 구성. get블록은 접근자 메소드 getter와 set블록은 setter와 동일한 역할을 함

  ```swift
  var 속성이름: 속성 자료형 {
    	get {
        	값을 리턴하는 코드
      }
    	set {
        	다른 속성을 새로운 값으로 설정하는 코드
      }
  }
  ```

- 계산 속성은 항상 var로 선언해야 함

- get블록은 필수, set블록은 생략 가능. 생략한 경우 읽기 전용 속성이 됨

- Person클래스의 age를 계산 속성으로 변경

  ```swift
  class Person {
    	var name: String = ""
    var birthDate: Date?
    var age: Int {
      	get {
          	if let date = birthDate {
              	let calendar = NSCalendar.current
              	let components = calendar.dateComponents([.year], from: date, to: Date())
              	
              	return components.year ?? -1
            }
          
          	return -1
        }
      	set {
          	let calendar = NSCalendar.current
          	birthDate = calendar.date(byAdding: .year, value:newValue*-1, to: Date())
        }
    }
  }
  ```

  - get블록을 구현하여 birthDate에 저장된 날짜를 통해 나이를 계산하여 리턴
  - set블록은 오늘 날짜에서 age에 할당된 수만큼의 연도를 뺸 날로 birthDate값을 변경

  ```swift
  let calendar = Calendar.current // 2016-05-03
  var components = DateComponents()
  
  components.year = 1983
  components.month = 3
  components.day = 17
  
  let james = Person()
  james.birthDate = calendar.date(from: components)
  print(james.age)
  // 33
  
  james.age = 10
  print(james.birthDate)
  // 2006-05-03
  ```

- set블록에서 속성에 할당된 새로운 값은 newValue 상수로 읽을 수 있음

- 필요시 새로운 값을 전달할 파라미터 직접 지정 가능. 단, 해당 경우에는 newValue상수는 더이상 사용 불가

  ```swift
  set (year) {
    	let calendar = NSCalendar.current
    	birthDate = calendar.date(byAdding: .year, value: year*-1, to: Date())
  }
  ```

- set블록을 생략하면 get블록을 감싸는 {}와 get키워드 생략가능

  ```swift
  class Person {
    	var name: String = ""
    	var birthDate: Date?
    	var age: Int {
        	if let date = birthDate {
            	let calendar = NSCalendar.current
            	let components = calendar.dateComponents([.year], from: date, to: Date())
            
            	return components.year ?? -1
          }
        
        	return -1
      }
  }
  ```



### 5. Type Property

