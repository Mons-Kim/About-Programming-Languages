# 서브스크립트

- []과 첨자를 사용해서 인스턴스 속성에 접근할 수 있는 문법

- 컬렉션에 포함된 요소에 접근할 때 주로 사용됨

  ```swift
  let list = ["iPhone", "iPad", "iPod", "Mac Pro"]
  let product = list[1]
  
  let country = ["kr": "한국", "us": "미국"]
  let korea = country["kr"]
  ```
  
- 클래스, 구조체, 열거형에서 구현 가능

- subscript 키워드로 시작

- 이름이 없는 메소드로 볼 수 있음. 파라미터 목록과 리턴형을 선언하는 문법은 메소드와 동일. 하지만 메소드와 달리 파라미터와 리턴형의 생략 불가

- 서브스크립트 구현 내부에는 get블록과 set블록이 포함. 계산 속성과 마찬가지로 get블록은 필수, set블록은 생략가능

- get블록만 구현한 서브스크립트를 읽기 전용 서브스크립트(Read-only Subscript)라고 함

  ```swift
  subscript(파라미터_목록) -> 리턴형 {
    	get {
        	값을 리턴하는 코드
      }
    	set {
        	값을 설정하는 코드
      }
  }
  ```

- "파라미터_목록"은 서브스크립트 문법으로 접근할 때 []사이에 전달하는 서브스크립트의 수와 자료형을 지정

- 일반적으로 하나의 정수 파라미터나 문자열 파라미터를 선언하지만, 필요에 따라 두 개 이상의 파라미터를 선언하거나 파라미터의 자료형을 정수, 문자열 이외의 자료형으로 지정 가능.

- 파라미터에 기본값 지정 불가. 입출력 파라미터 사용 불가



### 1. 서브스크립트 구현

- 예제 클래스

  ```swift
  class HeadQuarters {
    	private var squad: [SuperHero]
    
    	init(heroes: [SuperHero]) {
        	squad = heroes
      }
  }
  ```

- 







```swift
func 메소드_이름(파라미터_이름: 파라미터_자료형) -> 리턴형 {
  	실행할 코드
}
```

- SuperHero 클래스

  ```swift
  class SuperHero {
    	var name: String
    	var secretary: String?
    
    	init(heroName: String, secretaryName: String? = nil) {
        	name = heroName
        	secretary = secretaryName
      }
    
    	func callSecretary() {
        	if let name = secretary {
            	print("Hey, \(name)!")
          } else {
            	print("\(name) is working alone.")
          }
      }
  }
  ```

- 인스턴스 메소드는 동일한 클래스에 선언된 속성에 자유롭게 접근 가능. 인스턴스 속성에 접근할 때는 속성의 이름만으로 접근할 수 있지만, 형식 속성에 접근할 경우에는 반드시 형식 이름을 통해 접근해야 함

- 파라미터를 가진 메소드 구현

  ```swift
  class SuperHero {
    	// ...
    
    	func attack(weapon: String, target: String?) -> Bool {
        	if let target = target {
            	callSecretary()
            	print("Attack \(target) with \(weapon)!!!")
            	return true
          }
        
        	return false
      }
  }
  ```

  















### 2. 메소드 호출 문법

- 점 문법으로 메소드 호출. 함수를 호출하는 방식과 동일. 

- 인스턴스 메소드를 호출할 때는 리시버를 인스턴스 이름으로 지정하고, 형식 메소드를 호출할 때는 형식 이름으로 지정. 인스턴스 메소드를 형식 내부에서 호출할 때는 리시버 생략 가능

  ```swift
  리시버.메소드_이름(인자_레이블: 인자)
  ```

  ```swift
  let ironMan = SuperHero(heroName: "Iron Man", secretaryName: "Jarvis")
  ironMan.callSecretary()
  ironMan.attack(weapon: "Repulsor Beam", target: "Mandarin")
  // Hey, Jarvis
  // Hey, Jarvis
  // Attack Mandarin with Repulsor Beam!!!
  
  let thor = SuperHero(heroName: "Thor")
  thor.callSecretary()
  thor.attack(weapon: "Mj lnir", target: "Laufey")
  // Thor is working alone.
  // Thor is working alone.
  // Attack Laufey with Mj lnir!!!
  ```



### 3. 값 형식의 인스턴스 메소드

- 구조체와 열거형은 인스턴스 메소드를 구현가능.

  ```swift
  struct Weapon {
    	var name: String
    	var durability: Int
    
    	func use() {
        	if durability > 0 {
            	durability -= 1 // Error
          }
      }
  }
  ```

- 참조 형식의 인스턴스 메소드는 속성의 값을 자유롭게 변경할 수 있으나, 값 형식의 인스턴스 메소드는 기본적으로 속성의 값 변경 불가. 값 형식의 인스턴스 메소드 구현에 속성의 값을 변경하는 코드가 있다면 반드시 메소드를 mutating 키워드로 선언해야 함. 해당 키워드는 func 키워드 앞에 위치

  ```swift
  struct Weapon {
    	var name: String
    	var durability: Int
    
    	mutating func use() {
        	if durability > 0 {
            	durability -= 1
          }
      }
  }
  
  var repulsorBeam = Weapon(name: "Repulsor Beam", durability: 10)
  repulsorBeam.use()
  print(repulsorBeam.durability)
  // 9
  
  repulsorBeam.use()
  print(repulsorBeam.durability)
  // 8
  ```

- 값 형식을 let으로 선언할 경우 mutating 키워드로 선언했다 하더라도 함수 호출 불가.

  ```swift
  let repulsorBeam = Weapon(name: "Repulsor Beam", durability: 10)
  repulsorBeam.use() 	// Error
  ```

- 값 형식은 인스턴스 변수 내에서 인스턴스 자체를 완전히 교체 가능.

- mutating으로 선언한 인스턴스 함수 내에서 self에 새로운 인스턴스를 할당하면 현재 인스턴스가 새로운 인스턴스로 교체됨

  ```swift
  struct Weapon {
    	var name: String
    	var durability: Int
    
    	mutating func use() {
        	if durability > 0 {
            	durability -= 1
          }
      }
    
    	mutating func switchWeapon(_ name: String, durability: Int = 10) {
        	self = Weapon(name: name, durability: durability)
      }
  }
  
  var myWeapon = Weapon(name: "Repulsor Beam", durability: 10)
  print(myWeapon.name, myWeapon.durability)
  // Repulsor Beam 10
  
  myWeapon.switchWeapon("Mj lnir", durability: 10000)
  print(myWeapon.name, myWeapon.durability)
  // Mj lnir 10000
  ```

  

### 4. 형식 메소드

- 형식과 관련된 메소드. (전역 메소드, 클래스 메소드..)

- 형식 속성과 같이 static 키워드로 선언할 수 있고, 하위 클래스에서 재정의할 수 있도록 선언하려면 class 키워드로 선언할 것.

  ```swift
  static func 메소드_이름(파라미터_이름: 파라미터_자료형) -> 리턴형 {
    	실행할 코드
  }
  ```

  ```swift
  class func 메소드_이름(파라미터_이름: 파라미터_자료형) -> 리턴형 {
    	실행할 코드
  }
  ```



### 5. 메소드 표기법

- 메소드의 이름을 표기한 후 파라미터가 없으면 빈 ()를 뒷부분에 붙임.

- 파라미터가 있는 경우 인자 레이블과 :을 함께 표기. 인자 레이블이 없는 파라미터의 경우 _문자로 대체

  ```swift
  callSecretary()
  attack(weapon: target:)
  ```

- 메소드 표기법이 중요한 이유는 셀렉터를 생성할 때 사용되기 때문. 코코아 프레임워크는 다양한 부분에서 셀렉터를 사용하므로 메소드 표기법을 정확히 익혀두어야 함



### 6. 셀렉터

- 셀렉터는 메소드를 식별하기 위해 사용하는 객체로 C의 함수 포인터와 유사한 개념.

- 셀렉터의 자료형은 Selector. Swift 2.1버전까지는 문자열을 통해 셀렉터를 생성했지만, Swift 2.2버전부터 #selector를 통해 셀렉터를 생성

  ```swift
  let attackSelector = #selector(SuperHero.attack(weapon: target:))
  ```

- 셀렉터의 대상이 되는 메소드는 다음과 같이 @objc 키워드로 선언해야 함

  ```swift
  @objc func attack(weapon: String, target: String?) -> Bool {
    	// ...
  }
  ```

- 셀렉터는 코코아 프레임워크에서 특정 이벤트가 발생했을 때 실행하거나, 지연시간을 두고 실행해야 하는 메소드를 파라미터로 전달할 때 주로 사용

- ex) 버튼을 눌렀을 때 공격 메소드를 실행하는 코드를 구현할 때, 버튼과 연결할 메소드를 Selector 형식의 파라미터로 전달

  ```swift
  let button = UIButton()
  button.addTarget(ironMan, action: attackSelector, forControlEvents: .TouchInside)
  ```







