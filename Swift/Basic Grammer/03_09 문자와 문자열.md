# 기본 정보

- 문자 집합은 기본적으로 문자열로 추론됨. 문자 리터럴로 처리하고 싶으면 Character자료형을 명시적으로 지정해야 함

- swift4에서 멀티라인 문자열이 추가됨. 

  - 멀티라인 문자열은 """과 """사이에 포함

    ```swift
    // Single-line String Literal
    "Swift Programming"
    
    // Multiline String Literal
    """
    Swift
    "String"
    """
    ```

  - """는 반드시 한 줄에 단독으로 써야 함. 아래 오류 예시들 확인

    ```swift
    """Swift""" // Error
    
    """Swift // Error
    """
    
    """
    Swift""" // Error
    ```

  - 닫는 """의 위치가 문자열 리터럴의 들여쓰기 기준이 됨. 해당 위치보다 앞쪽에 문자표시 불가

    ```swift
    var str = """
    Multiline
    String Literal
    """
    print(str)
    //Multiline
    //String Literal
    
    str = """
    	Multiline
    	String Literal
    	"""
    print(str)
    //Multiline
    //String Literal
    
    str = """
    Multiline
    	String Literal
    """
    print(str)
    //Multiline
    //	  String Literal
    
    str = """
    Multiline
    	String Literal
    	"""				// Error
    ```

    


# 1. 문자열 자료형

- Objective-c : NSString(불변), NSMutableString(가변) 참조 형식
- Swift : String 값 형식
- String은 긴 문자열을 복사하는 경우, 참조 방식인 NSString에 비해 성능면에서 불리하지만, 컴파일러 최적화 수행으로 커버함



# 2. 가변성

- swift에서 String을 var로 선언한 경우, 다양한 연산자와 메소드를 통해 문자열의 변경이 가능
- 변경 과정에서 메모리 공간이 부족해지면, 변경된 문자열을 모두 저장할 수 있는 새로운 메모리 공간을 할당
- Exponential growth 전략 - 새로운 메모리 공간을 할당할 때마다 이전보다 두 배 이상 큰 공간을 할당하여, 메모리 공간이 새롭게 할당되는 횟수를 최대한 줄임으로써 대부분의 문자열 작업을 상수 시간에 처리할 수 있게 해 줌



# 3. 문자열 생성

- 문자열 리터럴 또는 다양한 생성자를 통해 생성

  ```swift
  let emptyString = ""
  let str = "Swift String"
  
  let emptyString = String()
  let str = String(stringLiteral: "Swift String")
  let nsstr = NSString(string: "Swift String")
  
  let intValue = 7
  let intString = String(intValue)
  
  let doubleValue = 12.34
  let doubleString = String(doubleValue)
  
  let bool = true
  let bootString = String(bool)
  
  let str = "Swift"
  let anotherString = String(str)
  
  let unicode = "\u{2665}"
  let unicodeString = String(unicode)
  
  let charlist: [Character] = ["S", "w", "i", "f", "t"]
  let strFromChar = String(charlist)
  ```

  

# 4. 문자 생성

- ""로 이루어진 리터럴은 항상 문자열 리터럴이 되기 때문에, Character 자료형을 명시적으로 지정해야 함

  ```swift
  let ch: Character = "A"
  
  let ch: Character = "AA" // Error
  
  let ch = Character("A")
  
  let ch = Character("AA") // Error
  ```

- 문자 리터럴의 공백은 문자열 리터럴의 공백과 다름

  ```swift
  let ch1: Character = " "
  let ch2 = Character(" ")
  
  let ch3: Character = "" // Error
  let ch4 = Character("") // Error
  let ch5 = Character()   // Error
  ```

  

# 5. 문자열 길이 확인

- NSString - length 속성을 통해 길이 확인 가능

  ```swift
  let str: NSString = "Foundation String"
  print(str.length)
  // 17
  ```

- String - count  속성을 통해 길이 확인 가능

  ```swift
  let str = "Swift String"
  print(str.count)
  // 12
  ```

- String은 isEmpty속성으로 비어있는지 확인 가능

  ```swift
  let str = "Swift String"
  if str.isEmpty {
      // ...
  }
  ```

  

# 6. 문자열 비교

- isEqual(to:) : 두 문자를 비교하여 같으면 true리턴. 대소문자 구분

  ```swift
  let a: NSString = "Apple"
  let b = "apple"
  
  if (a.isEqual(to:b)) {
      print("Equal")
  } else {
      print("Not Equal")
  }
  // Not Equal
  ```

- compare(_:) : 두 문자를 비교하여 ComparisonResult타입으로 리턴. 대소문자 구분. 정렬순서는 ASCII코드값

  ```swift
  let a: NSString = "Apple"
  let b = "apple"
  
  let result = a.compare(b)
  switch result {
      case .orderedAscending:
      	print("ASC")
      case .orderedSame:
      	print("SAME")
      case .orderedDescending:
      	print("DESC")
  }
  // ASC
  ```

- caseInsensitiveCompare(_:) : 대소문자구분이 필요없는 비교할 때. ComparisonResult타입으로 리턴.

  ```swift
  let a: NSString = "Apple"
  let b = "apple"
  
  if (a.caseInsensitiveCompare(b) == ComparisonResult.orderedSame) {
      print("Equal")
  } else {
      print("Not Equal")
  }
  // Equal
  ```

- String은 연산자(==, !=)으로 isEqual(to:)를 대체, 연산자(<. <=, >, >=)으로 compare(_:)를 대체 가능함.

- compare(_: options: range:) : 비교범위 설정. options 파라미터에 []는 옵션 사용안함을 의미.

  ```swift
  let a = "Swift 4.0"
  let b = "Swift"
  
  var result = a.compare(b)
  print(result.rawValue)
  // 1
  // ComparisonResult.orderedDescending
  
  let compareRange = b.startIndex...<b.endIndex
  result = a.compare(b, options: [], range: compareRange)
  print(result.rawValue)
  // 0
  // ComparisonResult.orderedSame
  ```

- hasPrefix(_:) : 접두어 비교

- hasSuffix(_:) : 접미어 비교

- 범위 비교시, 대소문자 구분이 필요없는 경우에는 compare(_: options: range:)의 options파라미터로 String.CompareOptions.caseInsensitive를 사용

  ```swift
  let a = "Swift"
  
  if a.hasPrefix("Swi") {
      // ...
  }
  
  if a.hasSuffix("Programming") {
      // ...
  }
  
  let compareRange = a.startIndex..<a.index(a.startIndex, offsetBy: 4)
  let result = a.compare("swi", options: [.caseInsensitive], range: compareRange)
  
  print(result.rawValue)
  // 1
  ```

  

# 7. 문자열 연결

- appending(_:) : 기존의 문자열에 파라미터로 전달한 문자열이 추가된 새로운 문자열을 리턴.

- appendingFormat(_:) : 파라미터로 전달하는 문자열에 형식화된 문자열을 사용 가능.

  ```swift
  let str1: NSString = "Swift"
  let str2 = str1.appending(" Programing")
  print(str2)
  // Swift Programming
  
  let str1: NSString = "Swift"
  let str2 = str1.appendingFormat(" %.1f %@", 4.0,"Programing")
  print(str2)
  // Swift 4.0 Programming
  ```

- 새로운 문자열을 만들지 않고 내용을 편집하려면 NSMutableString을 사용. 호출 메소드는 동일

- setString(_:) : NSMutableString에 저장된 문자열을 지정된 문자열로 교체. 빈문자열로 초기화하는 경우에는 빈문자열("")을 전달해야 함

  ```swift
  let str = NSMutableString(string: "Swift")
  
  str.append(" Programming")
  print(str)
  // Swift Programming
  
  str.setString("Swift")
  str.appendFormat(" %.1f, %@", 4.0, "Progamming")
  print(str)
  // Swift 4.0 Programming
  
  str.setString("")
  str.setString(nil) // Error
  ```

- String 문자열은 appendString(_:)과 유사한 이름의 메소드를 사용하지 않고, 연산자(+, +=)를 활용하여 두 문자열을 연결

- String 문자열은 appendFormat(_:)과 유사한 메소드를 사용하지 않고, String Interpolation을 사용

  ```swift
  let str = "Swift" + " Programming"
  print(str)
  // Swift Programming
  
  var str1 = "Swift"
  str1 += " Programming"
  print(str1)
  // Swift Programming
  
  let version = 4.0
  let str = "Swift \(version) Programming"
  print(str)
  // Swift 4.0 Programming
  ```

- append(_:) : String을 var로 선언하면 NSMutableString에서 제공하는 것과 유사한 메소드를 사용가능. NSMutableString과 마찬가지로 내부 저장 공간은 문자열의 길이에 따라 자동 관리됨.

  ```swift
  var str = "Swift"
  str.append(" Programming")
  str.append(Character("!"))
  
  print(str)
  // Swift Programming!
  ```

  

# 8. 문자열 인덱스와 범위

- character(at: ) : 지정된 인덱스의 unichar자료형으로 리턴. print()시에는 Character로 변환해야 함

  ```swift
  let nsstr: NSString = "Foundation String"
  let ch2 = nsstr.character(at: 0)
  
  print(ch2)
  // 70
  
  print(Character(UnicodeScalar(ch2)))
  // F
  ```

- NSMakeRange(i, n) : i번 인덱스부터 n개의 문자를 포함하는 범위를 표시

  ```swift
  let range = NSMakeRange(0, 3)
  ```

- startIndex : 첫번째 문자의 인덱스

  ```swift
  let str = "Swift String"
  let firstCh = str[str.startIndex]
  print(firstCh)
  // S
  ```

- endIndex : 마지막 인덱스. 마지막 문자의 인덱스+1

  ```swift
  let str = "Swift String"
  let lastCh = str[str.index(before: str.endIndex)]
  
  print(lastCh)
  // g
  ```

- 빈문자열 체크에 startIndex와 endIndex를 비교해서 판별 가능

  ```swift
  let emptyString = ""
  if emptyString.startIndex == emptyString.endIndex {
      // ...
  }
  ```

- index(before: ) : 전달된 인덱스의 이전 인덱스

- index(after: ) : 전달된 인덱스의 다음 인덱스

  ```swift
  let str = "Swift String"
  let SecondCh = str[str.index(after: str.startIndex)]
  print(SecondCh)
  // w
  ```

- index(_: offsetBy: ) : 전달된 인덱스에서 offset만큼 이동한 인덱스

  ```swift
  let str = "Swift String"
  let thirdCh = str[str.index(str.startIndex, offsetBy: 2)]
  print(thirdCh)
  // i
  ```

- 표시하는 인덱스가 범위 밖이면 NSRangeException이 발생함

  ```swift
  str[str.index(before: str.startIndex)] // Error
  str[str.index(after: str.endIndex)] // Error
  ```

  

# 9. 문자열 순회

- 빠른 열거를 통해 각 문자에 접근 가능

  ```swift
  let str = "Apple"
  for ch in str {
      print(ch)
  }
  ```



# 10. 문자열 편집

- (NSMutableString) insert(_: at: ) : 지정된 인덱스에 새로운 문자열 삽입

  ```swi
  let str = NSMutableString(string: "Swift Programming")
  str.insert(" 4.0", at: 5)
  print(str)
  // Swift 4.0 Programming
  ```

- (String) insert(_: at: ) : 지정된 인덱스에 새로운 문자를 삽입

- (String) insert(contentsOf: at: ) : 지정된 인덱스에 새로운 문자열 삽입. 인덱스 전달은 반드시 String.index로 지정해야 함

  ```swift
  var str = "Swift Programming"
  str.insert("!", at: str.endIndex)
  print(str)
  // Swift Programming
  
  str.insert(contentsOf: " 4.0", at: str.index(str.startIndex, offsetBy: 5))
  print(str)
  // Swift 4.0 Programming
  ```

- (NSString) replacingOccurrences(of: with: ) :

- (NSString) replacingCharacters(in: with: ) : 



# 11. 문자열 추출

- 박싱 - 값 형식을 참조 형식으로 바꾸는 것



# 12. 문자열 검색

- 박싱 - 값 형식을 참조 형식으로 바꾸는 것



# 13. 문자열 옵션

- 박싱 - 값 형식을 참조 형식으로 바꾸는 것



# 14. 문자열 변환

- 박싱 - 값 형식을 참조 형식으로 바꾸는 것



# 15. String Interpolation

- 박싱 - 값 형식을 참조 형식으로 바꾸는 것



# 16. 유니코드와 인코딩

- 박싱 - 값 형식을 참조 형식으로 바꾸는 것



# 17. 문자 집합

- 박싱 - 값 형식을 참조 형식으로 바꾸는 것



