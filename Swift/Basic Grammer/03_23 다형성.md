# 다형성

---



### 1. 오버로딩

- 함수의 이름은 함수를 식별하기 위한 요소이기 때문에 동일한 이름의 함수를 선언하면 중복 선언 오류가 발생함
- 오버로딩을 지원하는 언어는 함수의 시그니처(함수의 이름과 파라미터의 수, 자료형)로 함수를 식별함
- (함수의 시그니처 - 함수의 이름과 파라미터의 목록을 묶어 지칭)
- Swift에서 오버로딩을 지원하는 대상은 함수, 메소드, 서브스크립트, 생성자임
- 오버로드 구현 규칙
  - 이름이 동일한 함수는 선언된 파라미터의 수로 구분 가능해야 함
  - 위 조건이 모두 동일한 경우, 파라미터의 자료형으로 구분 가능해야 함
  - 위 조건이 모두 동일한 경우, Argument Label로 구분 가능해야 함
  - 위 조건이 모두 동일한 경우, 리턴형으로 구분 가능해야 함



#### 1.1 함수 오버로딩

- 자료형을 통해 구분

  ```swift
  func process(_ value: Int) {
    	print("process integer")
  }
  
  func process(_ value: Double) {
    	print("process double")
  }
  
  process(1)
  // process integer
  
  process(1.0)
  // process double
  ```

- Argument Label을 통해 구분

  ```swift
  func process(_ value: String) {
    	print("process(_:)")
  }
  
  func process(string value: String) {
    	print("process(string:)")
  }
  
  func process(str value: String) {
    	print("process(str:)")
  }
  
  process("swift")
  // process(_:)
  
  process(string: "swift")
  // process(string:)
  
  process(str: "swift")
  // process(str:)
  ```

- 리턴형을 통해 구분

  ```swift
  func process(_ value: Double) -> Int {
    	print("process double return integer")
    	return Int(value)
  }
  
  func process(_ value: Double) -> Double {
    	print("process double return double")
    	return value
  } 
  ```

  - 이 경우에는 호출시 리턴값을 사용하지 않는 경우 호출할 함수를 결정할 수 없으므로 컴파일 오류 발생함

  ```swift
  process(1.0) // Error
  ```

  - 리턴값을 사용하는 경우에도 자료형을 명시적으로 지정하지 않으면 컴파일 오류 발생함

  ```swift
  let intResult: Int = process(1.0)
  // process double return integer
  
  let intResult: Double = process(1.0)
  // process double return double
  
  let result = process(1.0) // Error
  ```

- 파라미터에 기본값이 지정되어 있는 경우는 파라미터가 없는 함수와 동일한 방식으로 호출 가능. 이 경우에는 파라미터가 없는 함수가 우선권을 갖음

  ```swift
  func process() {
    	print("process something")
  }
  
  func process(_ value: String = "str") {
    	print("process string")
  }
  
  process()
  // process something
  
  process("str")
  // process string
  ```



#### 1.2 메소드 오버로딩

- 함수의 오버로딩과 문법 동일. 함수 오버로딩 참조

  ```swift
  class MyClass {
    	func process(_ value: Int) {
        	print("process integer - instance")
      }
    
    	static func process(_ value: Int) {
        	print("process integer - type")
      }
    
    	func process(_ value: Double) {
        	print("process double")
      }
  }
  
  let cls = MyClass()
  
  cls.process(1)
  // process integer - instance
  
  cls.process(1.0)
  // process double
  
  MyClass.process(1)
  // process integer - type
  ```

  - 함수와 달리 메소드를 호출할 떄 형식 또는 인스턴스를 대상으로 호출하기 때문에 형식 함수와 인스턴스 함수가 동일한 시그니처 보유 가능



#### 1.3 생성자 오버로딩

- 이름이 init으로 고정

- 리턴형을 지정하지 않기 때문에 파라미터의 수와 자료형, Argument Label을 기준으로 식별

- 종류에 관계없이 하나의 형식 내에서 유일하게 식별가능해야 함

  ```swift
  class MyClass {
    	init() {
        	// ...
      }
    
    	init(value: Int = 0) {
        	// ...
      }
    
    	init?(value: Double) {
        	// ...
      }
    
    	convenience init(value: String) {
        	self.init()
        	// ...
      }
  }
  ```



#### 1.4 Subscript 오버로딩

- 이름이 subscript 키워드로 고정된 것을 제외하고 메소드의 오버로딩과 동일

  ```swift
  class MyClass {
    	subscript(index: Int) -> Int {
        	print("integer subscript return integer")
        	return 0
      }
    
    	subscript(index: Int) -> Double {
        	print("integer subscript return double")
        	return 0.0
      }
    
    	subscript(key: String) -> Double {
        	print("string subscript return double")
        	return 0.0
      }
  }
  
  let a = MyClass()
  
  let integerResult: Int = a[0]
  // integer subscript return integer
  
  let doubleResult: Double = a[0]
  // integer subscript return double
  
  let result = a["key"]
  // string subscript return double
  ```



### 2. 오버라이딩





### 3. 정적 타이핑과 동적 타이핑





### 4. 인트로스펙션 (Introspection)





### 5. 업캐스팅과 다운캐스팅





### 6. 정적 바인딩과 동적 바인딩





